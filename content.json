{"meta":{"title":"科长","subtitle":"你必须非常努力 才能看起来毫不费力","description":null,"author":"柯彰","url":"https://cohleke.github.io"},"pages":[{"title":"","date":"2018-02-28T06:18:14.946Z","updated":"2018-02-28T06:18:14.946Z","comments":false,"path":"categories/index.html","permalink":"https://cohleke.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-28T06:18:25.162Z","updated":"2018-02-28T06:18:25.162Z","comments":false,"path":"tags/index.html","permalink":"https://cohleke.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础知识学习1","slug":"Java基础知识学习1","date":"2018-03-09T14:40:12.000Z","updated":"2018-03-09T14:43:03.410Z","comments":true,"path":"2018/03/09/Java基础知识学习1/","link":"","permalink":"https://cohleke.github.io/2018/03/09/Java基础知识学习1/","excerpt":"","text":"问题Java中有哪几种引用？它们的含义和区别是什么？请用Java实现一个线程安全且高效的单例模式。","categories":[{"name":"Java","slug":"Java","permalink":"https://cohleke.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cohleke.github.io/tags/Java/"}]},{"title":"关于序列化的知识","slug":"关于序列化的知识","date":"2018-03-08T14:37:42.000Z","updated":"2018-03-09T14:39:50.226Z","comments":true,"path":"2018/03/08/关于序列化的知识/","link":"","permalink":"https://cohleke.github.io/2018/03/08/关于序列化的知识/","excerpt":"","text":"问题Parcelable和Serializable有什么用，它们有什么差别？自定义一个类让其实现Parcelable，大致流程是什么?","categories":[{"name":"Java","slug":"Java","permalink":"https://cohleke.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cohleke.github.io/tags/Java/"},{"name":"序列化","slug":"序列化","permalink":"https://cohleke.github.io/tags/序列化/"}]},{"title":"关于View的知识","slug":"关于View的知识","date":"2018-03-07T14:35:18.000Z","updated":"2018-03-09T14:42:42.311Z","comments":true,"path":"2018/03/07/关于View的知识/","link":"","permalink":"https://cohleke.github.io/2018/03/07/关于View的知识/","excerpt":"","text":"问题View的getWidth()和getMeasuredWidth()有什么区别吗？如何在onCreate中拿到View的宽度和高度？","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"https://cohleke.github.io/tags/View/"}]},{"title":"关于startActivityForResult","slug":"关于startActivityForResult","date":"2018-03-06T14:29:12.000Z","updated":"2018-03-09T14:37:25.669Z","comments":true,"path":"2018/03/06/关于startActivityForResult/","link":"","permalink":"https://cohleke.github.io/2018/03/06/关于startActivityForResult/","excerpt":"","text":"问题startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"https://cohleke.github.io/tags/Activity/"}]},{"title":"理解Activity的启动模式","slug":"理解Activity的启动模式","date":"2018-03-05T14:25:32.000Z","updated":"2018-03-09T14:37:22.056Z","comments":true,"path":"2018/03/05/理解Activity的启动模式/","link":"","permalink":"https://cohleke.github.io/2018/03/05/理解Activity的启动模式/","excerpt":"","text":"问题Activity的启动模式有哪几种，分别用于什么场景？清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"https://cohleke.github.io/tags/Activity/"}]},{"title":"清晰地理解Service","slug":"清晰地理解Service","date":"2018-03-04T14:23:45.000Z","updated":"2018-03-09T14:37:18.254Z","comments":true,"path":"2018/03/04/清晰地理解Service/","link":"","permalink":"https://cohleke.github.io/2018/03/04/清晰地理解Service/","excerpt":"","text":"问题Service的start和bind状态有什么区别？同一个Service，先startService，然后再bindService，如何把它停止掉？你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"Service","slug":"Service","permalink":"https://cohleke.github.io/tags/Service/"}]},{"title":"理解Java中的Synchronized关键字","slug":"理解Java中的synchronized关键字","date":"2018-03-03T14:16:12.000Z","updated":"2018-03-09T14:51:07.685Z","comments":true,"path":"2018/03/03/理解Java中的synchronized关键字/","link":"","permalink":"https://cohleke.github.io/2018/03/03/理解Java中的synchronized关键字/","excerpt":"","text":"问题理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。有如下一个类A1234567class A &#123; public synchronized void a() &#123; &#125; public synchronized void b() &#123; &#125;&#125; 然后创建两个对象12A a1 = new A();A a2 = new A(); 然后在两个线程中并发访问如下代码：12Thread1 Thread2a1.a(); a2.a(); 请问二者能否构成线程同步？ 如果A的定义是下面这种呢？1234567class A &#123; public static synchronized void a() &#123; &#125; public static synchronized void b() &#123; &#125;&#125; 回答Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。 Synchronized主修修饰对象为以下三种： 修饰普通方法 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。 修饰静态方法 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。 修饰代码块 其中普通代码块 如Synchronized（obj） 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。 Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。 Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。 简单来说 就是 Synchronized代码块更加灵活精确。 问题1 ：不能同步问题2：能同步","categories":[{"name":"Java","slug":"Java","permalink":"https://cohleke.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cohleke.github.io/tags/Java/"},{"name":"Synchronized","slug":"Synchronized","permalink":"https://cohleke.github.io/tags/Synchronized/"}]},{"title":"webviewclient WebChromeClient","slug":"WebChromeClient","date":"2018-03-02T02:34:18.000Z","updated":"2018-03-09T14:42:55.040Z","comments":true,"path":"2018/03/02/WebChromeClient/","link":"","permalink":"https://cohleke.github.io/2018/03/02/WebChromeClient/","excerpt":"","text":"WebViewClientWebViewClient中的常用方法有 onPageFinished(WebView view, String url) onPageStarted(WebView view, String url, Bitmap favicon) onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) shouldInterceptRequest(WebView view, String url) shouldOverrideUrlLoading(WebView view, String url) 等,以上方法都是webview中请求过程等事件的处理方法. WebChromeClientWebChromeClient中的常用方法有 onCloseWindow(WebView window) onConsoleMessage(ConsoleMessage consoleMessage) onJsAlert(WebView view, String url, String message, JsResult result) onJsConfirm(WebView view, String url, String message, JsResult result) onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) onPermissionRequest(PermissionRequest request) onReceivedIcon(WebView view, Bitmap icon) onReceivedTitle(WebView view, String title) onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) 等,以上方法都是webview和用户之间有交互的一些方法,如JS弹窗,文件选择弹窗,窗口关闭等","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"webview","slug":"webview","permalink":"https://cohleke.github.io/tags/webview/"},{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"}]}]}