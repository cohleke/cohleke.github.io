{"meta":{"title":"科长","subtitle":"种一棵树最好的时间是十年前，其次是现在。","description":null,"author":"科长","url":"https://cohleke.github.io"},"pages":[{"title":"","date":"2018-02-28T06:18:14.946Z","updated":"2018-02-28T06:18:14.946Z","comments":false,"path":"categories/index.html","permalink":"https://cohleke.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-28T06:18:25.162Z","updated":"2018-02-28T06:18:25.162Z","comments":false,"path":"tags/index.html","permalink":"https://cohleke.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"手动实现Quartz集群解决方案（动态增改任务、切换服务器、日志监控等）","slug":"Quartz集群解决方案（动态增改任务、服务器、日志监控等）","date":"2018-12-18T06:59:41.000Z","updated":"2018-12-19T08:33:58.747Z","comments":true,"path":"2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/","link":"","permalink":"https://cohleke.github.io/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/","excerpt":"","text":"手动实现Quartz集群解决方案概述在企业项目应用中必然要集成定时任务，绝大部分JavaEE工程采用Quartz和Spring的相应配置即可完成，若要修改任务的执行时间、执行服务器、任务的启动暂停等操作需要改变配置代码甚至需要重启服务器，本文是集群化服务器下动态的处理定时任务的一个实现。 本文主要对以下问题分析： Quartz集群原理 集群化服务器下的任务解决方案 Quartz原生集群方案的弊端 自定义实现集群化任务管理 希望读者具备： Java反射原理知识 JavaEE开发经验 Quartz集成经验 HTML5知识 开发环境JDK 1.8+ Spring版本 3.2 + Tomcat 8.5.32 Quartz版本 2.2.1+ Gradle3.5+ IntelliJ IDEA 2018.2.6 Gradle中必须引入quartz-jobs &apos;org.quartz-scheduler:quartz:2.2.1&apos;, &apos;org.quartz-scheduler:quartz-jobs:2.2.1&apos;, Spring配置中引入注册bean12&lt;bean id=&quot;schedulerFactoryBean&quot;class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot; /&gt; Quartz基本原理核心元素Quartz核心要素有Scheduler、Trigger、Job、JobDetail，其中trigger和job、jobDetail为元数据，而Scheduler为实际进行调度的控制器。 Trigger Trigger用于定义调度任务的时间规则，在Quartz中主要有四种类型的Trigger：SimpleTrigger、CronTrigger、DataIntervalTrigger和NthIncludedTrigger。 Job&amp;Jodetail Quartz将任务分为Job、JobDetail两部分，其中Job用来定义任务的执行逻辑，而JobDetail用来描述Job的定义（例如Job接口的实现类以及其他相关的静态信息）。对Quartz而言，主要有两种类型的Job，StateLessJob、StateFulJob Scheduler 实际执行调度逻辑的控制器，Quartz提供了DirectSchedulerFactory和StdSchedulerFactory等工厂类，用于支持Scheduler相关对象的产生。 核心元素间关系 主要线程在Quartz中，有两类线程，也即执行线程和调度线程，其中执行任务的线程通常用一个线程池维护。线程间关系如下图所示。 在quartz中，Scheduler调度线程主要有两个：regular Scheduler Thread（执行常规调度）和Misfire Scheduler Thread（执行错失的任务）。其中Regular Thread 轮询Trigger，如果有将要触发的Trigger，则从任务线程池中获取一个空闲线程，然后执行与改Trigger关联的job；Misfire Thraed则是扫描所有的trigger，查看是否有错失的，如果有的话，根据一定的策略进行处理。 数据存储Quartz中的trigger和job需要存储下来才能被使用。Quartz中有两种存储方式：RAMJobStore,JobStoreSupport，其中RAMJobStore是将trigger和job存储在内存中，而JobStoreSupport是基于jdbc将trigger和job存储到数据库中。RAMJobStore的存取速度非常快，但是由于其在系统被停止后所有的数据都会丢失，所以在集群应用中，必须使用JobStoreSupport。其中表结构如下表所示。 Table name Description QRTZ_CALENDARS 存储Quartz的Calendar信息 QRTZ_CRON_TRIGGERS 存储CronTrigger，包括Cron表达式和时区信息 QRTZ_FIRED_TRIGGERS 存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息 QRTZ_PAUSED_TRIGGER_GRPS 存储已暂停的Trigger组的信息 QRTZ_SCHEDULER_STATE 存储少量的有关Scheduler的状态信息，和别的Scheduler实例 QRTZ_LOCKS 存储程序的悲观锁的信息 QRTZ_JOB_DETAILS 存储每一个已配置的Job的详细信息 QRTZ_SIMPLE_TRIGGERS 存储简单的Trigger，包括重复次数、间隔、以及已触的次数 QRTZ_BLOG_TRIGGERS Trigger作为Blob类型存储 QRTZ_TRIGGERS 存储已配置的Trigger的信息 QRTZ_SIMPROP_TRIGGERS Quartz原生集群支持一个Quartz集群中的每个节点是一个独立的Quartz应用，它又管理着其他的节点。这就意味着你必须对每个节点分别启动或停止。Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的。 原生集群支持的问题原生集群支持需要在数据库新增十二张表，且每个任务调度是随机分配服务器，加上部分任务执行时间过长可能超时报错等等原因，可定制程度不高，固未采用原生集群方案。下面开始手写方案。 自定义实现集群化任务管理先展示成果 新增批次 立即运行一次 考虑到服务器不同配置。可自定义端口。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://cohleke.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://cohleke.github.io/tags/JavaEE/"},{"name":"Spring","slug":"Spring","permalink":"https://cohleke.github.io/tags/Spring/"}]},{"title":"常用排序算法kotlin实现","slug":"kotlin","date":"2018-04-21T12:52:03.000Z","updated":"2018-05-08T02:51:59.987Z","comments":true,"path":"2018/04/21/kotlin/","link":"","permalink":"https://cohleke.github.io/2018/04/21/kotlin/","excerpt":"","text":"常用排序算法kotlin实现冒泡排序kotlin版12345678910111213141516171819/*** * * 平均O(n^2)最坏O(n^2)最优O(n) 辅助空间O(1) 稳定 */private fun bubbleSort(sortList: IntArray) &#123; var didSwap: Boolean for (i in 0 until sortList.size - 1) &#123; didSwap = false for (j in 0 until sortList.size - 1 - i) &#123; if (sortList[j] &gt; sortList[j + 1]) &#123; swapByIndex(sortList, j, j + 1) didSwap = true &#125; &#125; if (!didSwap) &#123; return &#125; &#125;&#125; Java版12345678910111213141516/*** * * 平均O(n^2)最坏O(n^2)最优O(n) 辅助空间O(1) 稳定 */private void bubbleSort(int[] arr, int n) &#123; boolean flag; for (int i = 1; i &lt; n; i++) &#123; flag = false; for (int j = 0; j &lt; n - i; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123; swapByIndex(arr, j, j + 1); &#125; &#125; if (!flag) break; &#125;&#125; 快速排序kotlin版12345678910111213141516171819202122232425262728293031/*** * 平均O(n log n)最优O(n log n)最坏O(n^2) 辅助空间O(log n)~ O(n) 不稳定 */private fun quickSort(sortList: IntArray) &#123; loopForQuickSort(sortList, 0, sortList.size - 1)&#125; private fun loopForQuickSort(list: IntArray, start: Int, end: Int) &#123; if (start &gt;= end) &#123; return &#125; val k = partition(list, start, end) loopForQuickSort(list, start, k - 1) loopForQuickSort(list, k + 1, end)&#125;private fun partition(list: IntArray, begin: Int, end: Int): Int &#123; val x = list[end] var i = begin - 1 for (j in begin until end) &#123; if (list[j] &lt;= x) &#123; i++ swapByIndex(list, i, j) &#125; &#125; swapByIndex(list, end, i + 1) return i + 1&#125; Java版12345678910111213141516171819202122232425262728293031/*** * 平均O(n log n)最优O(n log n)最坏O(n^2) 辅助空间O(log n)~ O(n) 不稳定 */private void sort(int[] arr) &#123; quickSort(arr, 0, arr.length - 1);&#125;private void quickSort(int[] arr, int begin, int end) &#123; if (begin &gt;= end) return; int k = partition(arr, begin, end); quickSort(arr, begin, k - 1); quickSort(arr, k + 1, end);&#125;private int partition(int[] arr, int begin, int end) &#123; int x = arr[end]; int i = begin - 1; for (int j = begin; j &lt; end; j++) &#123; if (arr[j] &lt;= x) &#123; i++; swapByIndex(arr, i, j); &#125; &#125; swapByIndex(arr, end, i + 1); return i + 1;&#125; 选择排序kotlin版12345678910111213141516 /*** * 平均O(n^2)最坏O(n^2)最优O(n^2) 辅助空间O(1) 不稳定 * 效率差，但是可以用在“取出数列中最大/最小的几个值”的情况 */private fun selectionSort(sortList: IntArray) &#123; for (i in 0..sortList.size - 2) &#123; var minIndex = i for (j in i + 1 until sortList.size - 1) &#123; if (sortList[minIndex] &gt; sortList[j]) &#123; //找到比较小的值的索引 minIndex = j &#125; &#125; swapByIndex(sortList, i, minIndex) &#125;&#125; Java版1234567891011121314151617 /*** * 平均O(n^2)最坏O(n^2)最优O(n^2) 辅助空间O(1) 不稳定 * 效率差，但是可以用在“取出数列中最大/最小的几个值”的情况 */private void selectSort(int arr[], int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; n; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; swapByIndex(arr, minIndex, i); &#125; &#125;&#125; 插入排序kotlin版123456789101112131415/*** * 平均O(n^2)最坏O(n^2)最优O(n) 辅助空间O(1) 稳定 * 可以解决两个有序列表的合并问题，将第二个序列放在第一个序列后面，进行选择插入排序即可 */private fun insertSort(sortList: IntArray) &#123; for (i in 1 until sortList.size) &#123; for (j in i downTo 1) &#123; if (sortList[j] &gt; sortList[j - 1]) &#123; //已经找到当前元素要插入的位置 break &#125; swapByIndex(sortList, j - 1, j) &#125; &#125;&#125; Java版123456789101112131415/*** * 平均O(n^2)最坏O(n^2)最优O(n) 辅助空间O(1) 稳定 * 可以解决两个有序列表的合并问题，将第二个序列放在第一个序列后面，进行选择插入排序即可 */private void insertSort(int[] arr, int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = i + 1; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swapByIndex(arr, j, j - 1); &#125; else &#123; break; &#125; &#125; &#125;&#125; 希尔排序kotlin版1234567891011121314151617181920212223242526/*** * 平均O(n log n)最坏O(n log^2 n)最优O(n log^2 n) 辅助空间O(1) 不稳定 */ private fun shellSort(sortList: IntArray) &#123; var gap = 1 while (gap &lt; sortList.size / 3) &#123; //寻找合适的步长 gap = gap * 3 + 1 &#125; while (gap &gt; 0) &#123; for (i in gap until sortList.size) &#123; val temp = sortList[i] var j = i - gap while (j &gt;= 0) &#123; //将以temp为元素起点，以gap为步进长度构成的list进行插入运算 if (sortList[j] &lt;= temp) &#123; break &#125; sortList[j + gap] = sortList[j] j -= gap &#125; sortList[j + gap] = temp &#125; gap /= 3 &#125; &#125; Java版12345678910111213141516171819202122232425262728/*** * 平均O(n log n)最坏O(n log^2 n)最优O(n log^2 n) 辅助空间O(1) 不稳定 */ private void shellSort(int arr[], int length) &#123; int temp = 0; int incre = length; while (true) &#123; incre = incre / 2; //对分组进行遍历 for (int i = 0; i &lt; incre; i++) &#123; //插入排序 for (int j = i + incre; j &lt; length; j += incre) &#123; for (int k = j; k &gt; i; k -= incre) &#123; if (arr[k] &lt; arr[k - incre]) &#123; swapByIndex(arr, k, k - incre); &#125; else &#123; break; &#125; &#125; &#125; &#125; //无法分组，表示排序结束 if (incre == 1) &#123; break; &#125; &#125; &#125; 堆排序kotlin版123456789101112131415161718192021222324252627282930313233343536373839404142/*** * 平均O(n log n)最坏O(n log n)最优O(n log n) 辅助空间O(1) 不稳定 * */private fun heapSort(sortList: IntArray) &#123; val len = sortList.size for (i in len / 2 - 1 downTo 0) &#123; //这一步的作用就是建立最大堆模型 //这里选出来的i，就是当前堆的最后一个三角的单位中的爸爸，也就是说从最后一个单元开始向上递增构建最大堆 loopForHeap(sortList, i, len) &#125; for (i in len - 1 downTo 1) &#123; //依次拿出堆顶元素放在数列最后 swapByIndex(sortList, 0, i) //对剩余的0--&gt;i的堆重拍，即可找到剩余数列中的最大值 loopForHeap(sortList, 0, i) &#125;&#125; private fun loopForHeap(list: IntArray, start: Int, end: Int) &#123; if (start &gt;= end) &#123; return &#125; val dad = start var son = dad * 2 + 1 if (son &gt;= end) &#123; //儿子索引已经超过数组最大索引 return &#125; if (son + 1 &lt; end &amp;&amp; list[son] &lt; list[son + 1]) &#123; //说明两个儿子之间右边的更大 son++ &#125; if (list[dad] &lt;= list[son]) &#123; //交换父子 swapByIndex(list, dad, son) //因为父子交换了，因此该分支下面所有堆都要重排 //并且索引从当前换位的son开始直到该分支最后一位元素 loopForHeap(list, son, end) &#125;&#125; Java版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*** * 平均O(n log n)最坏O(n log n)最优O(n log n) 辅助空间O(1) 不稳定 * */private void MinHeap_Sort(int a[], int n) &#123; int temp = 0; MakeMinHeap(a, n); for (int i = n - 1; i &gt; 0; i--) &#123; swapByIndex(arr, 0, i); MinHeapFixdown(a, 0, i); &#125;&#125;private void MakeMinHeap(int a[], int n) &#123; //从倒数第二层开始排序，取自己的孩子进行排序，这样所有的节点都排序到了 for (int i = (n - 1) / 2; i &gt;= 0; i--) &#123; MinHeapFixdown(a, i, n); &#125;&#125;private void MinHeapFixdown(int a[], int i, int n) &#123; int j = 2 * i + 1; //左节点 int temp = 0; //j&lt;n：如果左节点小于节点总数，表示该节点有节点，否则该节点是叶子节点是不需要调整的 while (j &lt; n) &#123; //j+1&lt;n：存在右节点，a[j+1]&lt;a[j]：左右子节点中寻找最小的 if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) &#123; //将节点移到右节点 j++; &#125; //较大节点在下面 if (a[i] &lt;= a[j]) break; //较大节点在上面，则将大节点下移 swapByIndex(arr, i, j); //复位 i = j; j = 2 * i + 1; &#125;&#125; 基数排序kotlin版1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** * 平均O(d*(n+r))最坏O(d*(n+r))最优O(d*(n+r)) 辅助空间O(n+r) 稳定 * d 为位数，r 为基数，n 为原数组个数 */private fun radixSort(sortList: IntArray) &#123; //寻找当前序列中的最大值，目的是计算最大的位数 var max = 0 for (i in 0 until sortList.size - 1) &#123; if (sortList[i] &gt; max) &#123; //找到当前序列最大数 max = sortList[i] &#125; &#125; //通过最大数找到最大数的位数 val maxDigit = max.toString().length var mod = 10 var dev = 1 for (i in 0 until maxDigit) &#123; val counter = mutableMapOf&lt;Int, ArrayList&lt;Int&gt;&gt;() for (j in 0 until sortList.size) &#123; // 取出某个数的第mod位的值 // 比如数字123，123%100=23,23继续计算23/10=2，最终拿到123的中间位数字 val bucket = (sortList[j] % mod) / dev //按照当前位数作为key以此存入counter的map中 if (counter[bucket] == null) &#123; counter[bucket] = ArrayList&lt;Int&gt;() &#125; counter[bucket]?.add(sortList[j]) &#125; var pos = 0 for (i in 0..9) &#123; //这里一定使用0--9的索引，因为对counter来说，里面的map的key只能是这个组合，并且一定要按照从0到9的顺序弹出 counter[i]?.forEach &#123; //依次将counter中的值放入列表中 //第一次经过进--出的操作就对个位数字进行了排序 //第二次经过进--出的操作就对十位进行了排序 //经过上面两次排序，就达到了个位+十位的综合排序，也就完成了两位数字的整体排序 sortList[pos++] = it &#125; &#125; dev *= 10 mod *= 10 &#125;&#125; Java版123456789101112131415161718192021222324252627282930313233/*** * 平均O(d*(n+r))最坏O(d*(n+r))最优O(d*(n+r)) 辅助空间O(n+r) 稳定 * d 为位数，r 为基数，n 为原数组个数 */private void radixSort(int[] array, int d) &#123; int n = 1;//代表位数对应的数：1,10,100... int k = 0;//保存每一位排序后的结果用于下一位的排序输入 int length = array.length; int[][] bucket = new int[10][length];//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里 int[] order = new int[length];//用于保存每个桶里有多少个数字 while (n &lt; d) &#123; for (int num : array) //将数组array里的每个数字放在相应的桶里 &#123; int digit = (num / n) % 10; bucket[digit][order[digit]] = num; order[digit]++; &#125; for (int i = 0; i &lt; length; i++)//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果 &#123; if (order[i] != 0)//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中 &#123; for (int j = 0; j &lt; order[i]; j++) &#123; array[k] = bucket[i][j]; k++; &#125; &#125; order[i] = 0;//将桶里计数器置0，用于下一次位排序 &#125; n *= 10; k = 0;//将k置0，用于下一轮保存位排序结果 &#125;&#125; 交换位置12345private fun swapByIndex(list: IntArray, x: Int, y: Int) &#123; val temp = list[x] list[x] = list[y] list[y] = temp&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://cohleke.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://cohleke.github.io/tags/Kotlin/"}]},{"title":"Android 指纹适配","slug":"Android-指纹相关","date":"2018-03-12T02:53:01.000Z","updated":"2018-03-13T03:02:04.355Z","comments":true,"path":"2018/03/12/Android-指纹相关/","link":"","permalink":"https://cohleke.github.io/2018/03/12/Android-指纹相关/","excerpt":"","text":"待填坑 指纹识别适配指纹识别适配会有很多问题，这些问题可以从下面三种情况中看出: Google官方支持指纹识别的标准接口是在Android6.0开始的，如果各个厂商都升级到6.0并且硬件上都给予支持，那么我们按照标准的指纹识别接口使用就可以了。 如果在android6.0发布以后，手机厂商来不及升级，但是工程师们参考了官方指纹识别的代码，把代码移植到他们的6.0版本以下的系统，或者参照Google提供的接口自己实现了一套指纹识别机制，只是对开发者暴露的接口一样，这样就可以像使用标准接口一样使用，但是这种情况就难说了，实现不好的可能本身就有很多bug，适配起也比较麻烦，不过起码还是能用的。 如果厂商在Google之前就已经做了指纹识别，那这种情况肯定不能使用官方标准接口，如果要适配这种设备，只能使用厂商提供的第三方指纹识别SDK。","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"Fingerprint","slug":"Fingerprint","permalink":"https://cohleke.github.io/tags/Fingerprint/"},{"name":"指纹","slug":"指纹","permalink":"https://cohleke.github.io/tags/指纹/"}]},{"title":"Webview填坑（hybrid / X5内核 等）","slug":"WebChromeClient","date":"2018-03-02T02:34:18.000Z","updated":"2018-05-08T02:56:13.988Z","comments":true,"path":"2018/03/02/WebChromeClient/","link":"","permalink":"https://cohleke.github.io/2018/03/02/WebChromeClient/","excerpt":"","text":"webview填坑地理位置原生处理覆盖WebChromeClient里的onGeolocationPermissionsShowPrompt方法请求原生定位123456@Overridepublic void onGeolocationPermissionsShowPrompt(String origin,Callback callback) &#123; callback.invoke(origin, true, false); super.onGeolocationPermissionsShowPrompt(origin, callback);&#125; cookies相关添加cookies12345CookieSyncManager.createInstance(context);CookieManager cookieManager = CookieManager.getInstance();////以上为原生webview方法，以下为x5的方法com.tencent.smtt.sdk.CookieSyncManager.createInstance(context);com.tencent.smtt.sdk.CookieManager cookieManager = com.tencent.smtt.sdk.CookieManager.getInstance(); 清除cookies123CookieManager.getInstance().removeAllCookie();////以上为原生webview方法，以下为x5的方法com.tencent.smtt.sdk.CookieManager.getInstance().removeAllCookie(); WebView与 JS 双向交互总结对于Android调用JS代码的方法有2种：通过WebView的loadUrl()通过WebView的evaluateJavascript()对于JS调用Android代码的方法有3种：通过WebView的addJavascriptInterface()进行对象映射通过 WebViewClient 的shouldOverrideUrlLoading()方法回调拦截 url通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt()方法回调拦截JS对话框alert()、confirm()、prompt()消息 不使用JS，实现原生拍照及图库 覆盖WebChromeClient里的方法12345678910111213141516171819202122232425 @Overridepublic boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) &#123; mUploadCallbackAboveL = filePathCallback; take(); return true;&#125;public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123; mUploadMessage = uploadMsg; take();&#125;public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123; mUploadMessage = uploadMsg; take();&#125;public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123; mUploadMessage = uploadMsg; take();&#125; take方法123456789101112131415161718192021222324252627282930313233343536 private void take() &#123; File imageStorageDir = new File( Environment .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), \"MyApp\"); if (!imageStorageDir.exists()) &#123; imageStorageDir.mkdirs(); &#125; File file = new File(imageStorageDir + File.separator + \"IMG_\" + String.valueOf(System.currentTimeMillis()) + \".jpg\"); imageUri = Uri.fromFile(file); final List&lt;Intent&gt; cameraIntents = new ArrayList&lt;Intent&gt;(); final Intent captureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); final PackageManager packageManager = getPackageManager(); final List&lt;ResolveInfo&gt; listCam = packageManager.queryIntentActivities( captureIntent, 0); for (ResolveInfo res : listCam) &#123; final String packageName = res.activityInfo.packageName; final Intent i = new Intent(captureIntent); i.setComponent(new ComponentName(res.activityInfo.packageName, res.activityInfo.name)); i.setPackage(packageName); i.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); cameraIntents.add(i); &#125; Intent i = new Intent(Intent.ACTION_GET_CONTENT); i.addCategory(Intent.CATEGORY_OPENABLE); i.setType(\"image/*\"); Intent chooserIntent = Intent.createChooser(i, \"Image Chooser\"); chooserIntent.putExtra(Intent.EXTRA_INITIAL_INTENTS, cameraIntents.toArray(new Parcelable[] &#123;&#125;)); X5WebViewActivity.this.startActivityForResult(chooserIntent, FILECHOOSER_RESULTCODE);&#125; 覆盖onActivityResult及定义onActivityResultAboveL12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 @Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == FILECHOOSER_RESULTCODE) &#123; if (null == mUploadMessage &amp;&amp; null == mUploadCallbackAboveL) return; Uri result = data == null || resultCode != RESULT_OK ? null : data .getData(); if (mUploadCallbackAboveL != null) &#123; onActivityResultAboveL(requestCode, resultCode, data); &#125; else if (mUploadMessage != null) &#123; if (result != null) &#123; String path = getPath(getApplicationContext(), result); Uri uri = Uri.fromFile(new File(path)); mUploadMessage.onReceiveValue(uri); &#125; else &#123; mUploadMessage.onReceiveValue(imageUri); &#125; mUploadMessage = null; &#125; &#125;&#125;@SuppressLint(\"NewApi\")private void onActivityResultAboveL(int requestCode, int resultCode, Intent data) &#123; if (requestCode != FILECHOOSER_RESULTCODE || mUploadCallbackAboveL == null) &#123; return; &#125; Uri[] results = null; if (resultCode == Activity.RESULT_OK) &#123; if (data == null) &#123; results = new Uri[] &#123; imageUri &#125;; &#125; else &#123; String dataString = data.getDataString(); ClipData clipData = data.getClipData(); if (clipData != null) &#123; results = new Uri[clipData.getItemCount()]; for (int i = 0; i &lt; clipData.getItemCount(); i++) &#123; ClipData.Item item = clipData.getItemAt(i); results[i] = item.getUri(); &#125; &#125; if (dataString != null) results = new Uri[] &#123; Uri.parse(dataString) &#125;; &#125; &#125; if (results != null) &#123; mUploadCallbackAboveL.onReceiveValue(results); mUploadCallbackAboveL = null; &#125; else &#123; results = new Uri[] &#123; imageUri &#125;; mUploadCallbackAboveL.onReceiveValue(results); mUploadCallbackAboveL = null; &#125; return;&#125; WebView开启硬件加速12345678910111213Application级别：&lt;applicationandroid:hardwareAccelerated=\"true\" ...&gt; Activity级别：&lt;activity android:hardwareAccelerated=\"false\" ...&gt; Window级别：getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View级别： mView.setLayerType(View.LAYER_TYPE_HARDWARE, null); WebViewClient中的常用方法有 onPageFinished(WebView view, String url) onPageStarted(WebView view, String url, Bitmap favicon) onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) shouldInterceptRequest(WebView view, String url) shouldOverrideUrlLoading(WebView view, String url) 等,以上方法都是webview中请求过程等事件的处理方法. WebChromeClient中的常用方法有 onCloseWindow(WebView window) onConsoleMessage(ConsoleMessage consoleMessage) onJsAlert(WebView view, String url, String message, JsResult result) onJsConfirm(WebView view, String url, String message, JsResult result) onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) onPermissionRequest(PermissionRequest request) onReceivedIcon(WebView view, Bitmap icon) onReceivedTitle(WebView view, String title) onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) 等,以上方法都是webview和用户之间有交互的一些方法,如JS弹窗,文件选择弹窗,窗口关闭等","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"webview","slug":"webview","permalink":"https://cohleke.github.io/tags/webview/"}]},{"title":"Android Activity启动过程","slug":"Android Activity启动过程","date":"2018-02-01T08:59:21.000Z","updated":"2018-03-11T09:11:38.943Z","comments":true,"path":"2018/02/01/Android Activity启动过程/","link":"","permalink":"https://cohleke.github.io/2018/02/01/Android Activity启动过程/","excerpt":"","text":"Android - Activity启动过程概述从点击桌面应用图标到应用显示的过程我们再熟悉不过了，下面我们来分析下这个过程都做了什么。 本文主要对以下问题分析： ActivityThread 是什么，它是一个线程吗，如何被启动的？ ActivityClientRecord 与 ActivityRecord 是什么？ Context 是什么，ContextImpl，ContextWapper 是什么？ Instrumentation 是什么？ Application 是什么，什么时候创建的，每个应用程序有几个 Application？ 点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？ Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？ Launcher 我们知道 Android 系统启动后已经启动了 Zygote，ServiceManager，SystemServer 等系统进程；ServiceManager 进程中完成了 Binder 初始化；SystemServer 进程中 ActivityManagerService，WindowManagerService，PackageManagerService 等系统服务在 ServiceManager 中已经注册；最后启动了 Launcher 桌面应用。 其实 Launcher 本身就是一个应用程序，运行在自己的进程中，我们看到的桌面就是 Launcher 中的一个 Activity。 应用安装的时候，通过 PackageManagerService 解析 apk 的 AndroidManifest.xml 文件，提取出这个 apk 的信息写入到 packages.xml 文件中，这些信息包括：权限、应用包名、icon、apk 的安装位置、版本、userID 等等。packages.xml 文件位于系统目录下/data/system/packages.xml。 同时桌面 Launcher 会为安装过的应用生成不同的应用入口，对应桌面上的应用图标，下面分析点击应用图标的到应用启动的过程。 点击 Launcher 中应用图标 点击 Launcher 中应用图标将会执行以下方法 1234567891011121314151617Launcher.startActivitySafely()Launcher.startActivity()//以上两个方法主要是检查将要打开的 Activity 是否存在Activity.startActivity()//这段代码大家已经很熟悉，经常打开 Activity 用的就是这个方法Activity.startActivityForResult()//默认 requestCode = -1，也可通过调用 startActivityForResult() 传入 requestCode。 //然后通过 MainThread 获取到 ApplicationThread 传入下面方法。Instrumentation.execStartActivity()//通过 ActivityManagerNative.getDefault() 获取到 ActivityManagerService 的代理为进程通讯作准备。ActivityManagerNative.getDefault().startActivity()ActivityManagerProxy.startActivity()//调用代理对象的 startActivity() 方法，发送 START_ACTIVITY_TRANSACTION 命令。 在 system_server 进程中的服务端 ActivityManagerService 收到 START_ACTIVITY_TRANSACTION 命令后进行处理，调用 startActivity() 方法。 12345678910111213141516171819202122232425262728ActivityManagerService.startActivity() -&gt; startActivityAsUser(intent, requestCode, userId)//通过 UserHandle.getCallingUserId() 获取到 userId 并调用 startActivityAsUser() 方法。ActivityStackSupervisor.startActivityMayWait() -&gt; resolveActivity()//通过 intent 创建新的 intent 对象，即使之前 intent 被修改也不受影响。 然后调用 resolveActivity()。//然后通过层层调用获取到 ApplicationPackageManager 对象。PackageManagerService.resolveIntent() -&gt; queryIntentActivities()//获取 intent 所指向的 Activity 信息，并保存到 Intent 对象。PackageManagerService.chooseBestActivity()//当存在多个满足条件的 Activity 则会弹框让用户来选择。ActivityStackSupervisor.startActivityLocked()//获取到调用者的进程信息。 通过 Intent.FLAG_ACTIVITY_FORWARD_RESULT 判断是否需要进行 startActivityForResult 处理。 //检查调用者是否有权限来调用指定的 Activity。 //创建 ActivityRecord 对象，并检查是否运行 App 切换。ActivityStackSupervisor.startActivityUncheckedLocked() -&gt; startActivityLocked()//进行对 launchMode 的处理[可参考 Activity 启动模式]，创建 Task 等操作。//启动 Activity 所在进程，已存在则直接 onResume()，不存在则创建 Activity 并处理是否触发 onNewIntent()。ActivityStack.resumeTopActivityInnerLocked()//找到 resume 状态的 Activity，执行 startPausingLocked() 暂停该 Activity，同时暂停所有处于后台栈的 Activity，找不到 resume 状态的 Activity 则回桌面。//如果需要启动的 Activity 进程已存在，直接设置 Activity 状态为 resumed。 调用下面方法。ActivityStackSupervisor.startSpecificActivityLocked()//进程存在调用 realStartActivityLocked() 启动 Activity，进程不存在则调用下面方法。 fork 新进程从 Launcher 点击图标，如果应用没有启动过，则会 fork 一个新进程。创建新进程的时候，ActivityManagerService 会保存一个 ProcessRecord 信息，Activity 应用程序中的AndroidManifest.xml 配置文件中，我们没有指定 Application 标签的 process 属性，系统就会默认使用 package 的名称。每一个应用程序都有自己的 uid，因此，这里 uid + process 的组合就可以为每一个应用程序创建一个 ProcessRecord。每次在新建新进程前的时候会先判断这个 ProcessRecord 是否已存在，如果已经存在就不会新建进程了，这就属于应用内打开 Activity 的过程了。 12ActivityManagerService.startProcessLocked()//进程不存在请求 Zygote 创建新进程。 创建成功后切换到新进程。 进程创建成功切换至 App 进程，进入 app 进程后将 ActivityThread 类加载到新进程，并调用 ActivityThread.main() 方法 12345678ActivityThread.main()//创建主线程的 Looper 对象，创建 ActivityThread 对象，ActivityThread.attach() 建立 Binder 通道，开启 Looper.loop() 消息循环。ActivityThread.attach()//开启虚拟机各项功能，创建 ActivityManagerProxy 对象，调用基于 IActivityManager 接口的 Binder 通道 ActivityManagerProxy.attachApplication()。ActivityManagerProxy.attachApplication()//发送 ATTACH_APPLICATION_TRANSACTION 命令 此时只创建了应用程序的 ActivityThread 和 ApplicationThread，和开启了 Handler 消息循环机制，其他的都还未创建， ActivityThread.attach(false) 又会最终到 ActivityMangerService 的 attachApplication，这个工程其实是将本地的 ApplicationThread 传递到 ActivityMangerService。然后 ActivityMangerService 就可以通过 ApplicationThread 的代理 ApplicationThreadProxy 来调用应用程序 ApplicationThread.bindApplication，通知应用程序的 ApplicationThread 已和 ActivityMangerService 绑定，可以不借助其他进程帮助直接通信了。此时 Launcher 的任务也算是完成了。 在 system_server 进程中的服务端 ActivityManagerService 收到 ATTACH_APPLICATION_TRANSACTION 命令后进行处理，调用 attachApplication()。 123ActivityMangerService.attachApplication() -&gt; attachApplicationLocked()//首先会获取到进程信息 ProcessRecord。 绑定死亡通知，移除进程启动超时消息。 获取到应用 ApplicationInfo 并绑定应用 IApplicationThread.bindApplication(appInfo)。//然后检查 App 所需组件。 Activity: 检查最顶层可见的 Activity 是否等待在该进程中运行，调用 ActivityStackSupervisor.attachApplicationLocked()。 Service：寻找所有需要在该进程中运行的服务，调用 ActiveServices.attachApplicationLocked()。 Broadcast：检查是否在这个进程中有下一个广播接收者，调用 sendPendingBroadcastsLocked()。 此处讨论 Activity 的启动过程，只讨论 ActivityStackSupervisor.attachApplicationLocked() 方法。 12345ActivityStackSupervisor.attachApplicationLocked() -&gt; realStartActivityLocked()//将该进程设置为前台进程 PROCESS_STATE_TOP，调用 ApplicationThreadProxy.scheduleLaunchActivity()。ApplicationThreadProxy.scheduleLaunchActivity()//发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令 发送送完 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，还会发送 BIND_APPLICATION_TRANSACTION 命令来创建 Application。 12ApplicationThreadProxy.bindApplication()//发送 BIND_APPLICATION_TRANSACTION 命令 App 进程初始化在 app 进程中，收到 BIND_APPLICATION_TRANSACTION 命令后调用 ActivityThread.bindApplication()。 12ActivityThread.bindApplication()//缓存 Service，初始化 AppBindData，发送消息 H.BIND_APPLICATION。 ApplicationThreadProxy.bindApplication(…) 会传来这个应用的一些信息，如ApplicationInfo，Configuration 等，在 ApplicationThread.bindApplication 里会待信息封装成A ppBindData，通过 1sendMessage(H.BIND_APPLICATION, data) 将信息放到应用里的消息队列里，通过 Handler 消息机制，在 ActivityThread.handleMeaasge 里处理 H.BIND_APPLICATION 的信息，调用 AplicationThread.handleBindApplication。 1234567891011121314151617181920212223242526272829303132333435handleBindApplication(AppBindData data) &#123; Process.setArgV0(data.processName);//设置进程名 ... //初始化 mInstrumentation if(data.mInstrumentation!=null) &#123; mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); &#125; else &#123; mInstrumentation = new Instrumentation(); &#125; //创建Application，data.info 是个 LoadedApk 对象。 Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; //调用 Application 的 onCreate()方法。 mInstrumentation.callApplicationOnCreate(app);&#125;public Application makeApplication(boolean forceDefaultAppClass,Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; String appClass = mApplicationInfo.className; java.lang.ClassLoader cl = getClassLoader(); //此时新建一个 Application 的 ContextImpl 对象， ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); //通过在 handleBindApplication 创建的 mInstrumentation 对象新建一个 Application 对象，同时进行 attach。 app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext); appContext.setOuterContext(app);&#125;//设置进程名，获取 LoadedApk 对象，创建 ContextImpl 上下文//LoadedApk.makeApplication() 创建 Application 对象，调用 Application.onCreate() 方法。 Instrumentation： 1234567891011121314151617public Application newApplication(ClassLoader cl, String className, Context context) &#123; return newApplication(cl.loadClass(className), context);&#125;Instrumentation类：static public Application newApplication(Class&lt;?&gt; clazz, Context context) &#123; //实例化 Application Application app = (Application)clazz.newInstance(); // Application 和 context绑定 app.attach(context); return app;&#125;//attach 就是将新建的 ContextImpl 赋值到 mBase，这个 ContextImpl 对象就是所有Application 内 Context 的具体实现，同时赋值一些其他的信息如 mLoadedApk。final void attach(Context context) &#123; mBase = base; mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; 这时 Application 就创建好了，这点很重要，很多资料里说 Application 是在performLaunchActivity() 里创建的，因为 performLaunchActivity() 也有mInstrumentation.newApplication 这个调用，newApplication() 函数中可看出会先判断是否以及创建了 Application，如果之前已经创建，就返回已创建的 Application 对象。 Activity 启动上面 fork 进程时会发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，在 app 进程中，收到 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令后调用 ApplicationThread.scheduleLaunchActivity()。 1234567891011121314151617181920212223242526272829303132ApplicationThread.scheduleLaunchActivity()//发送消息 H.LAUNCH_ACTIVITY。sendMessage(H.LAUNCH_ACTIVITY, r);ActivityThread.handleLaunchActivity()//最终回调目标 Activity 的 onConfigurationChanged()，初始化 WindowManagerService。//调用 ActivityThread.performLaunchActivity()ActivityThread.performLaunchActivity() &#123; //类似 Application 的创建过程，通过 classLoader 加载到 activity. activity = mInstrumentation.newActivity(classLoader, component.getClassName(), r.intent); //因为 Activity 有界面，所以其 Context 是 ContextThemeWrapper 类型，但实现类仍是ContextImpl. Context appContext = createBaseContextForActivity(r, activity); activity.attach(context,mInstrumentation,application,...); //与 Window 进行关联 //attach 后调用 activity 的 onCreate()方法。 mInstrumentation.callActivityOnCreate(activity,...) &#125;//在ActivityThread.handleLaunchActivity里，接着调用Activity.performCreate() -&gt; onCreate()//最终回调目标 Activity 的 onCreate()。Activity.setContentView()//设置 layout 布局ActivityThread.performResumeActivity()//最终回调目标 Activity 的 onResume()。 总结Activity 的整体启动流程如图所示： ActivityThread 是什么，它是一个线程吗，如何被启动的？ 它不是一个线程，它是运行在 App 进程中的主线程中的一个方法中。当 App 进程创建时会执行 ActivityThread.main()，ActivityThread.main() 首先会创建 Looper 执行 Looper.prepareMainLooper()；然后创建 ActivityThread 并调用 ActivityThread.attach() 方法告诉 ActivityManagerService 我们创建了一个应用 并将 ApplicationThread 传给 ActivityManagerService；最后调用 Looper.loop()。 ActivityClientRecord 与 ActivityRecord 是什么？ 记录 Activity 相关信息，比如：Window，configuration，ActivityInfo 等。ActivityClientRecord 是客户端的，ActivityRecord 是 ActivityManagerService 服务端的。 Context 是什么，ContextImpl，ContextWapper 是什么？ Context 定义了 App 进程的相关环境，Context 是一个接口，ContextImpl 是子类，ContextWapper 是具体实现。 应用资源是在 Application 初始化的时候，也就是创建 Application，ContextImpl 的时候，ContextImpl 就包含这个路径，主要就是对就是 ResourcesManager 这个单例的引用。 可以看出每次创建 Application 和 Acitvity 以及 Service 时就会有一个 ContextImpl 实例，ContentProvider 和B roadcastReceiver 的 Context 是其他地方传入的。 所以 Context 数量 = Application 数量 + Activity 数量 + Service 数量，单进程情况下 Application 数量就是 1。 Instrumentation 是什么？ 管理着组件 Application，Activity，Service 等的创建，生命周期调用。 Application 是什么，什么时候创建的，每个应用程序有几个 Application？ Application 是在 ActivityThread.handleBindApplication() 中创建的，一个进程只会创建一个 Application，但是一个应用如果有多个进程就会创建多个 Application 对象。 点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？ 点击 Launcher 时会创建一个新进程来开启 Activity，而应用内打开 Activity，如果 Activity 不指定新进程，将在原来进程打开，是否开启新进程实在 ActivityManagerService 进行控制的，上面分析得到，每次开启新进程时会保存进程信息，默认为 应用包名 + 应用UID，打开 Activity 时会检查请求方的信息来判断是否需要新开进程。Launcher 打开 Activity 默认 ACTIVITY_NEW_TASK，新开一个 Activity 栈来保存 Activity 的信息。 Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？ Activity.onCreate() 完成了 App 进程，Application，Activity 的创建，调用 setContentView() 给 Activity 设置了 layout 布局。 Activity.onResume() 完成了 Activity 中 Window 与 WindowManager 的关联，并对所有子 View 进行渲染并显示。 参考资料 startActivity启动过程分析 Android应用程序的Activity启动过程简要介绍和学习计划 Android 应用点击图标到Activity界面显示的过程分析 《深入理解 Android 内核设计思想》","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://cohleke.github.io/tags/Activity/"},{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"}]},{"title":"Android常见内存泄露分析","slug":"Android常见内存泄露分析","date":"2018-01-21T15:15:41.000Z","updated":"2018-03-09T15:31:37.308Z","comments":true,"path":"2018/01/21/Android常见内存泄露分析/","link":"","permalink":"https://cohleke.github.io/2018/01/21/Android常见内存泄露分析/","excerpt":"","text":"如何找到项目中存在的内存泄露的地方？确定是否存在内存泄露Android Monitors的内存分析最直观的看内存增长情况，知道该动作是否发生内存泄露。动作发生之前：GC完后内存1.4M; 动作发生之后：GC完后内存1.6M 使用MAT内存分析工具MAT分析heap的总内存占用大小来初步判断是否存在泄露Heap视图中有一个Type叫做data object，即数据对象，也就是我们的程序中大量存在的类类型的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。我们反复执行某一个操作并同时执行GC排除可以回收掉的内存，注意观察data object的Total Size值，正常情况下Total Size值都会稳定在一个有限的范围内，也就是说由于程序中的的代码良好，没有造成对象不被垃圾回收的情况。反之如果代码中存在没有释放对象引用的情况，随着操作次数的增多Total Size的值会越来越大。那么这里就已经初步判断这个操作导致了内存泄露的情况。 先找怀疑对象(哪些对象属于泄露的)MAT对比操作前后的hprof来定位内存泄露是泄露了什么数据对象。（这样做可以排除一些对象，不用后面去查看所有被引用的对象是否是嫌疑）快速定位到操作前后所持有的对象哪些是增加了(GC后还是比之前多出来的对象就可能是泄露对象嫌疑犯)技巧：Histogram中还可以对对象进行Group，比如选择Group By Package更方便查看自己Package中的对象信息。 MAT分析hprof来定位内存泄露的原因所在。(哪个对象持有了上面怀疑出来的发生泄露的对象) Dump出内存泄露“当时”的内存镜像hprof，分析怀疑泄露的类； 把上面2得出的这些嫌疑犯一个一个排查个遍。步骤： 进入Histogram，过滤出某一个嫌疑对象类 然后分析持有此类对象引用的外部对象（在该类上面点击右键List Objects—&gt;with incoming references） 再过滤掉一些弱引用、软引用、虚引用，因为它们迟早可以被GC干掉不属于内存泄露(在类上面点击右键Merge Shortest Paths to GC Roots—&gt;exclude all phantom/weak/soft etc.references) 逐个分析每个对象的GC路径是否正常此时就要进入代码分析此时这个对象的引用持有是否合理，这就要考经验和体力了！（比如上课的例子中：旋转屏幕后MainActivity有两个，肯定MainActivity发生泄露了，那谁导致他泄露的呢？原来是我们的CommonUtils类持有了旋转之前的那个MainActivity他，那是否合理？结合逻辑判断当然不合理，由此找到内存泄露根源是CommonUtils类持有了该MainActivity实例造成的。怎么解决？罪魁祸首找到了，怎么解决应该不难了，不同情况解决办法不一样，要靠你的智慧了。） context.getapplictioncontext()可以吗？可以！！只要让CommonUtils类不直接只有MainActivity的实例就可以了。 一般我是最笨的方法解决new出来对象，用完后把它 = null;这样算不算优化假如：方法里面定义的对象，要去管吗？一般不需要管。 自己=null，要自己去控制所有对象的生命周期 判断各种空指针，有点麻烦。 但是在很多时候去想到主动将对象置为null是很好的习惯。 判断一个应用里面内存泄露避免得很好，怎么看？当app退出的时候，这个进程里面所有的对象应该就都被回收了，尤其是很容易被泄露的（View，Activity）是否还内存当中。可以让app退出以后，查看系统该进程里面的所有的View、Activity对象是否为0.工具：使用AndroidStudio–AndroidMonitor–System Information–Memory Usage查看Objects里面的views和Activity的数量是否为0.命令行模式： 内存泄露经常出现的例子内存泄露(Memory Leak)： 进程中某些对象已经没有使用价值了，但是他们却还可以直接或者间接地被引用到GC Root导致无法回收。 当内存泄露过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM.内存溢出（OOM）： 当应用占用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出。比如：加载大图片。 静态变量引起的内存泄露当调用getInstance时，如果传入的context是Activity的context。只要这个单利没有被释放，那么这个Activity也不会被释放一直到进程退出才会释放。12345678910111213141516public class CommUtil &#123; private static CommUtil instance; private Context context; private CommUtil(Context context)&#123; this.context = context; &#125; public static CommUtil getInstance(Context mcontext)&#123; if(instance == null)&#123; instance = new CommUtil(mcontext); &#125; // else&#123; // instance.setContext(mcontext); // &#125; return instance; &#125; 非静态内部类引起内存泄露(包括匿名内部类) 错误的示范：123456789101112131415public void loadData()&#123;//隐式持有MainActivity实例。MainActivity.this.a new Thread(new Runnable() &#123; @Override public void run() &#123; while(true)&#123; try &#123; //int b=a; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; 解决方案：将非静态内部类修改为静态内部类。（静态内部类不会隐式持有外部类） 当使用软引用或者弱引用的时候，MainActivity难道很容易或者可以被GC回收吗？》GC回收的机制是什么？当MainActivity不被任何的对象引用。虽然Handler里面用的是软引用/弱引用，但是并不意味着不存在其他的对象引用该MainActivity。我连MainActivity都被回收了，那他里面的Handler还玩个屁。 不需要用的监听未移除会发生内存泄露例1：1234567891011tv.setOnClickListener();//监听执行完回收对象//add监听，放到集合里面tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() &#123; @Override public void onWindowFocusChanged(boolean b) &#123; //监听view的加载，view加载出来的时候，计算他的宽高等。 //计算完后，一定要移除这个监听 tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this); &#125;&#125;); 例2：12345SensorManager sensorManager = getSystemService(SENSOR_SERVICE); Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL); sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST); //不需要用的时候记得移除监听 sensorManager.unregisterListener(listener); 资源未关闭引起的内存泄露情况比如：BroadCastReceiver、Cursor、Bitmap、IO流、自定义属性attributeattr.recycle()回收。当不需要使用的时候，要记得及时释放资源。否则就会内存泄露。 无限循环动画没有在onDestroy中停止动画，否则Activity就会变成泄露对象。比如：轮播图效果。","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"内存泄露","slug":"内存泄露","permalink":"https://cohleke.github.io/tags/内存泄露/"},{"name":"性能优化","slug":"性能优化","permalink":"https://cohleke.github.io/tags/性能优化/"}]},{"title":"Android Handler消息机制","slug":"Android Handler消息机制","date":"2018-01-07T08:41:27.000Z","updated":"2018-03-11T08:58:17.364Z","comments":true,"path":"2018/01/07/Android Handler消息机制/","link":"","permalink":"https://cohleke.github.io/2018/01/07/Android Handler消息机制/","excerpt":"","text":"Android-Handler消息机制概述Android 的消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper 的工作过程。 Handler 的主要作用是将某个任务切换到 Handler 所在的线程中去执行。 Handler机制Handler工作流程 Looper 每个线程中最多只能有一个 Looper 对象，由 Looper 来管理此线程里的 MessageQueue (消息队列)。 可以通过 Looper.myLooper() 获取当前线程的 Looper 实例，通过 Looper.getMainLooper() 获取主（UI）线程的 Looper 实例。 Lopper 会以无限循环的形式去查找是否有新消息，如果有就处理消息，否则就一直等待着。 Handler 你可以构造 Handler 对象来与 Looper 沟通，通过 push 发送新消息到 MessageQueue 里；或者通过 handleMessage 接收 Looper 从 MessageQueue 取出来消息。 MessageQueue MessageQueue是一个消息队列，内部存储了一组消息，以队列的形式对外提供插入和删除的工作，内部采用单链表的数据结构来存储消息列表。 ActivityThread 我们经常提到的主线程，也叫UI线程，它就是 ActivityThread，主线程启动会默认初始化一个 Looper 并创建 Handler。 一个线程中只有一个 Looper 实例，一个 MessageQueue 实例，可以有多个 Handler 实例。 ThreadLocal 一个线程内部的数据存储类，通过它可以在指定线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获得数据。 对于 Handler 来说，它需要获取当前线程的 Looper ,而 Looper 的作用于就是线程并且不同的线程具有不同的 Looper ，通过 ThreadLocal 可以轻松实现线程中的存取。 ThreadLocal原理：不同线程访问同一个ThreadLoacl的get方法，ThreadLocal的get方法会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找对应的Value值。 源码分析通过上面分析我们知道使用 Handler 之前必须先调用 Looper.prepare(); 进行初始化，我们先看下 Looper 的源码。 1. Looper 工作原理先看一下 Looper 工作流程 Looper 源码最上面的注释里有一个使用示例如下，可以清晰的看出 Looper 的使用方法。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare();//先初始化 Looper mHandler = new Handler() &#123;//创建 Handler public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop();//启用 Looper 的 loop 方法开启消息轮询 &#125;&#125; 接续看一下 Looper 的完整源码，分析下工作过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public final class Looper &#123; static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //每个线程都会有一个ThreadLocal 用来保存 Looper对象（里面包含了主线程和 MessageQueue） private static Looper sMainLooper; // 主线程的 Looper final MessageQueue mQueue;//保存消息队列 final Thread mThread;//保存主线程 public static void prepare() &#123;//为当前线程创建 Looper prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; //一个线程只能有一个 Looper， 否则抛出异常 throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));//将创建的 Looper 放入 ThreadLocal &#125; //初始化主线程的 Looper public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; //获取主线程的 Looper public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125; &#125; //在当前线程中开启轮询 public static void loop() &#123; final Looper me = myLooper();//从 ThreadLocal 中取出当前线程的 Looper 对象 if (me == null) &#123; //Looper 没有调用 Looper.prepare() 初始化，抛出异常 throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue;//从 Looper 对象中取出消息队列 for (;;) &#123;//死循环 Message msg = queue.next(); // 不断的取出消息 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); //取出消息的 target (也就是 Handler)，执行分发消息的操作 &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ... msg.recycleUnchecked();//消息已经分发，进行回收操作 &#125; &#125; public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();//从 ThreadLocal 中取出当前线程的 Looper 对象 &#125; private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//创建消息队列 mThread = Thread.currentThread();//保存当前线程 &#125; public void quit() &#123; mQueue.quit(false);//直接退出消息循环，不管是否还有消息 &#125; public void quitSafely() &#123; mQueue.quit(true);//执行完所有的消息，退出消息循环 &#125; ...&#125; 2. MessageQueue 工作原理在 Looper 中创建了 MessageQueue，我们接着看下 MessageQueue 是怎么工作的。 MessageQueue 工作流程 MessageQueue的构造方法。 123456MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //构造函数，quitAllowed 用来标识是否允许退出。 //主线程是不允许退出的（不然会退出整个程序），子线程可以退出。 mPtr = nativeInit();&#125; 然后我们再看一下 MessageQueue.enqueueMessage() 的源码，分析下是怎么添加消息的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 如果消息队列里面没有消息，或者消息的执行时间比里面的消息早，就把这条消息设置成第一条消息。 //一般不会出现这种情况，因为系统一定会有很多消息。 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123;//如果消息队列里面有消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123;//找到消息队列里面的最后一条消息 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg;//把消息添加到最后 &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 知道了怎么添加消息，我们再看下 MessageQueue.next() 方法是怎么取出消息的，也就是 Looper.loop() 方法中不断取消息的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages;//拿到当前的消息队列 if (msg != null &amp;&amp; msg.target == null) &#123; //处理异步的消息，暂不讨论 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; //取出一条消息，消息队列往后移动一个 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse();//标记为已使用 return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ... &#125;&#125; 我们知道 MessageQueue 是个链表结构，里面保存的是 Message，我们再看下 Message 是什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final class Message implements Parcelable &#123; public int what;//消息类型，标识消息的作用 public int arg1;//整型参数1 public int arg2;//整型参数2 public Object obj;//复杂对象参数 public Messenger replyTo; public int sendingUid = -1; /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;//标记消息已使用 /** If set message is asynchronous */ /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;//标记消息是否异步 /** Flags to clear in the copyFrom method */ /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE; /*package*/ int flags;//消息当前标记 /*package*/ long when;//消息执行时间 /*package*/ Bundle data; /*package*/ Handler target;//Handler 用于执行 handleMessage(); /*package*/ Runnable callback;//消息是一个Runnable // sometimes we store linked lists of these things /*package*/ Message next;//下一个消息 private static final Object sPoolSync = new Object();//控制并发访问 private static Message sPool;//消息池 private static int sPoolSize = 0;//消息池数量 private static final int MAX_POOL_SIZE = 50;//消息最大数量 ...&#125; 3. Handler 工作原理在 Message 中我们看到了 target 是一个 Handler，我们看下 Handler 是怎么与 Looper 和 MessageQueue 一起搭配工作的。 看一下 Handler 的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class Handler &#123; public interface Callback &#123; public boolean handleMessage(Message msg); &#125; public void handleMessage(Message msg) &#123;&#125; /** * 消息处理 */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123;//如果消息体是 Runnable 就执行 run() handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; //如果创建 Handler 时传入了 Callback，就执行 Callback 里面的逻辑 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg);//如果上述两种都没有实现，就执行 handleMessage 的逻辑 &#125; &#125; public Handler() &#123; this(null, false); &#125; public Handler(Callback callback) &#123; this(callback, false); &#125; public Handler(Looper looper) &#123;//可以指定关联哪个线程的 Looper this(looper, null, false); &#125; public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false); &#125; public Handler(boolean async) &#123; this(null, async); &#125; /** * 主线程调用的构造方法，主线程已经调用了 Looper.prepareMainLooper(); * * @hide */ public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//取出主线程的 Looper if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue;//把 Handler 的 mQueue 指向 Looper 中的 mQueue mCallback = callback; mAsynchronous = async; &#125; /** * 第二种构造方法，专门给子线程中创建 Handler 时使用的 * * @hide */ public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; //发送 Runnable 消息 public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; //一般更新 UI 时发送的消息，延时时间为0 public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; //发送延时消息 public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; //发送指定时间发送的消息 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; //把字节传入 Message 中一起发送 //Looper 中需要使用 Handler 来执行 dispatchMessage 方法 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125;&#125; 4. ActivityThread 创建默认的 Handler上面说过，ActivityThread 主线程默认是有一个 Handler 的，我们来看一下主线程是怎么创建默认的 Handler 的。 我们看一下 ActivityThread 类中的 main 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser();//准备一些相关环境，给我们的组件启动 // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper();//初始化主线程 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();//开启消息轮询，不断取出消息 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 在 Activity 可以直接用 runOnUiThread() 来使用默认的 Handler 发送消息，我们来看下它是怎么实现的。 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123;//非主线程，发送 Runnable 消息 mHandler.post(action); &#125; else &#123;//在主线程中直接执行 run() action.run(); &#125;&#125; 5. HandlerThread 异步消息处理机制 HandlerThread 继承了 Thread，是一种可以使用 Handler 的 Thread； 在 run 方法中通过 looper.prepare() 来开启消息循环，这样就可以在 HandlerThread 中创建Handler了； 外界可以通过一个 Handler 的消息方式来通知 HandlerThread 来执行具体任务；确定不使用之后，可以通过 quit 或 quitSafely 方法来终止线程执行。 先分析一下 HandlerThread 的源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class HandlerThread extends Thread &#123; //线程的优先级 int mPriority; //线程的id int mTid = -1; //一个与Handler关联的Looper对象 Looper mLooper; public HandlerThread(String name) &#123; super(name); //设置优先级为默认线程 mPriority = android.os.Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; //可重写方法，Looper.loop之前在线程中需要处理的其他逻辑在这里实现 protected void onLooperPrepared() &#123; &#125; //HandlerThread线程的run方法 @Override public void run() &#123; //获取当前线程的id mTid = Process.myTid(); //创建Looper对象 //这就是为什么我们要在调用线程的start()方法后才能得到Looper(Looper.myLooper不为Null) Looper.prepare(); //同步代码块，当获得mLooper对象后，唤醒所有线程 synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; //设置线程优先级 Process.setThreadPriority(mPriority); //Looper.loop之前在线程中需要处理的其他逻辑 onLooperPrepared(); //建立了消息循环 Looper.loop(); //一般执行不到这句，除非quit消息队列 mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; //线程死了 return null; &#125; //同步代码块，正好和上面run方法中同步块对应 //只要线程活着并且mLooper为null，则一直等待 // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; //退出消息循环 looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; //退出消息循环 looper.quitSafely(); return true; &#125; return false; &#125; public int getThreadId() &#123; //返回线程id return mTid; &#125;&#125; HandlerThread 使用代码示例 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private HandlerThread mHandlerThread = null; private Handler mThreadHandler = null; private Handler mUiHandler = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandlerThread = new HandlerThread(\"HandlerWorkThread\"); //必须在实例化mThreadHandler之前调运start方法，原因上面源码已经分析了 mHandlerThread.start(); //将当前mHandlerThread子线程的Looper传入mThreadHandler，使得 //mThreadHandler的消息队列依赖于子线程（在子线程中执行） mThreadHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(null, \"在子线程中处理！id=\"+Thread.currentThread().getId()); //从子线程往主线程发送消息 mUiHandler.sendEmptyMessage(0); &#125; &#125;; mUiHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(null, \"在UI主线程中处理！id=\"+Thread.currentThread().getId()); &#125; &#125;; //从主线程往子线程发送消息 mThreadHandler.sendEmptyMessage(1); &#125;&#125; 总结到此 Handler 消息机制的源码已经分析完了，相信你一定明白了 Handler 消息机制。一句话，每个线程可以创建一个 Looper ，每个 Looper 轮询着一个 MessageQueue 不断取出消息，有消息则回调给 Handler，Handler 负责向 MessageQueue 中发送消息和处理回调的消息来完成线程之间的转换。","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"https://cohleke.github.io/tags/Handler/"}]},{"title":"Android Binder进程间通讯","slug":"Android Binder进程间通讯","date":"2017-12-30T08:41:27.000Z","updated":"2018-03-11T08:51:41.181Z","comments":true,"path":"2017/12/30/Android Binder进程间通讯/","link":"","permalink":"https://cohleke.github.io/2017/12/30/Android Binder进程间通讯/","excerpt":"","text":"Android-Binder进程间通讯概述最近在学习 Binder 机制，在网上查阅了大量的资料，也看了老罗的 Binder 系列的博客和 Innost 的深入理解 Binder 系列的博客，都是从底层开始讲的，全是 C 代码，虽然之前学过 C 和 C++，然而各种函数之间花式跳转，看的我都怀疑人生。 毫不夸张的讲每看一遍都是新的内容，跟没看过一样。 后来又看到了 Gityuan 的博客看到了一些图解仿佛发现了新大陆。 下面就以图解的方式介绍下 Binder 机制，相信你看这篇文章，一定有所收获。 什么是 Binder？Binder 是 Android 系统中进程间通讯（IPC）的一种方式，也是 Android 系统中最重要的特性之一。 Android 中的四大组件 Activity，Service，Broadcast，ContentProvider，不同的 App 等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。 理解 Binder 对于理解整个 Android 系统有着非常重要的作用，如果对 Binder 不了解，就很难对 Android 系统机制有更深入的理解。 1. Binder 架构 Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。 Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。 2. Binder 机制 首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。 有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码： 12//获取WindowManager服务引用WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); 获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。 有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。 怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。 3. Binder 驱动我们先来了解下用户空间与内核空间是怎么交互的。 先了解一些概念 用户空间/内核空间详细解释可以参考 Kernel Space Definition； 简单理解如下： Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 系统调用/内核态/用户态虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？ Kernel space can be accessed by user processes only through the use of system calls. 用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。 内核模块/驱动通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。 在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动; 驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作； 驱动就是操作硬件的接口，为了支持 Binder 通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。 熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。 4. Binder 进程与线程 对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。 Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。 5. ServiceManager 启动了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。 ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。 ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。 ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。 6. ServiceManager 注册服务 注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。 事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。 7. ServiceManager 获取服务 获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。 8. 进行一次完整通讯 我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。 首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给 ServiceManager，同时客户端线程进入等待状态。 ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。 总结好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。 努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。 网上资料很多，个人觉得比较好的如下： Bander设计与实现 老罗的 Android进程间通信（IPC）机制Binder简要介绍和学习计划 系列 Innost的 深入理解Binder 系列 Gityuan的 Binder系列 (基于 Android 6.0) Binder学习指南 参考资料 Binder系列 Binder学习指南","categories":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://cohleke.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"https://cohleke.github.io/tags/Binder/"}]}]}