<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>科长</title>
  
  <subtitle>会写一点代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cohleke.github.io/"/>
  <updated>2018-03-09T14:42:55.040Z</updated>
  <id>https://cohleke.github.io/</id>
  
  <author>
    <name>柯彰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webviewclient WebChromeClient</title>
    <link href="https://cohleke.github.io/2018/03/02/WebChromeClient/"/>
    <id>https://cohleke.github.io/2018/03/02/WebChromeClient/</id>
    <published>2018-03-02T02:34:18.000Z</published>
    <updated>2018-03-09T14:42:55.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a>WebViewClient</h2><h3 id="WebViewClient中的常用方法有"><a href="#WebViewClient中的常用方法有" class="headerlink" title="WebViewClient中的常用方法有"></a>WebViewClient中的常用方法有</h3><ul><li>onPageFinished(WebView view, String url)</li><li>onPageStarted(WebView view, String url, Bitmap favicon)</li><li>onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)</li><li>shouldInterceptRequest(WebView view, String url)</li><li>shouldOverrideUrlLoading(WebView view, String url)</li></ul><p>等,以上方法都是webview中请求过程等事件的处理方法.</p><h2 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a>WebChromeClient</h2><h3 id="WebChromeClient中的常用方法有"><a href="#WebChromeClient中的常用方法有" class="headerlink" title="WebChromeClient中的常用方法有"></a>WebChromeClient中的常用方法有</h3><ul><li>onCloseWindow(WebView window)</li><li>onConsoleMessage(ConsoleMessage consoleMessage)</li><li>onJsAlert(WebView view, String url, String message, JsResult result)</li><li>onJsConfirm(WebView view, String url, String message, JsResult result)</li><li>onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result)</li><li>onPermissionRequest(PermissionRequest request)</li><li>onReceivedIcon(WebView view, Bitmap icon)</li><li>onReceivedTitle(WebView view, String title)</li><li>onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)</li></ul><p>等,以上方法都是webview和用户之间有交互的一些方法,如JS弹窗,文件选择弹窗,窗口关闭等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebViewClient&quot;&gt;&lt;a href=&quot;#WebViewClient&quot; class=&quot;headerlink&quot; title=&quot;WebViewClient&quot;&gt;&lt;/a&gt;WebViewClient&lt;/h2&gt;&lt;h3 id=&quot;WebViewClient中的常用方法有&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="webview" scheme="https://cohleke.github.io/tags/webview/"/>
    
  </entry>
  
  <entry>
    <title>Android Activity启动过程</title>
    <link href="https://cohleke.github.io/2018/02/01/Android%20Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://cohleke.github.io/2018/02/01/Android Activity启动过程/</id>
    <published>2018-02-01T08:59:21.000Z</published>
    <updated>2018-03-11T09:11:38.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Activity启动过程"><a href="#Android-Activity启动过程" class="headerlink" title="Android - Activity启动过程"></a>Android - Activity启动过程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从点击桌面应用图标到应用显示的过程我们再熟悉不过了，下面我们来分析下这个过程都做了什么。</p><p>本文主要对以下问题分析：</p><ul><li>ActivityThread 是什么，它是一个线程吗，如何被启动的？</li><li>ActivityClientRecord 与 ActivityRecord 是什么？</li><li>Context 是什么，ContextImpl，ContextWapper 是什么？</li><li>Instrumentation 是什么？</li><li>Application 是什么，什么时候创建的，每个应用程序有几个 Application？</li><li>点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？</li><li>Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？</li></ul><h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h2><img src="/2018/02/01/Android%20Activity启动过程/01.png" title="系统启动过程"><p>我们知道 Android 系统启动后已经启动了 Zygote，ServiceManager，SystemServer 等系统进程；ServiceManager 进程中完成了 Binder 初始化；SystemServer 进程中 ActivityManagerService，WindowManagerService，PackageManagerService 等系统服务在 ServiceManager 中已经注册；最后启动了 Launcher 桌面应用。</p><p>其实 Launcher 本身就是一个应用程序，运行在自己的进程中，我们看到的桌面就是 Launcher 中的一个 Activity。</p><p>应用安装的时候，通过 PackageManagerService 解析 apk 的 AndroidManifest.xml 文件，提取出这个 apk 的信息写入到 packages.xml 文件中，这些信息包括：权限、应用包名、icon、apk 的安装位置、版本、userID 等等。packages.xml 文件位于系统目录下/data/system/packages.xml。</p><p>同时桌面 Launcher 会为安装过的应用生成不同的应用入口，对应桌面上的应用图标，下面分析点击应用图标的到应用启动的过程。</p><h2 id="点击-Launcher-中应用图标"><a href="#点击-Launcher-中应用图标" class="headerlink" title="点击 Launcher 中应用图标"></a>点击 Launcher 中应用图标</h2><img src="/2018/02/01/Android%20Activity启动过程/02.png" title="点击 Launcher 执行过程"><p>点击 Launcher 中应用图标将会执行以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Launcher.startActivitySafely()</span><br><span class="line">Launcher.startActivity()</span><br><span class="line"><span class="comment">//以上两个方法主要是检查将要打开的 Activity 是否存在</span></span><br><span class="line"></span><br><span class="line">Activity.startActivity()</span><br><span class="line"><span class="comment">//这段代码大家已经很熟悉，经常打开 Activity 用的就是这个方法</span></span><br><span class="line"></span><br><span class="line">Activity.startActivityForResult()</span><br><span class="line"><span class="comment">//默认 requestCode = -1，也可通过调用 startActivityForResult() 传入 requestCode。 </span></span><br><span class="line"><span class="comment">//然后通过 MainThread 获取到 ApplicationThread 传入下面方法。</span></span><br><span class="line"></span><br><span class="line">Instrumentation.execStartActivity()</span><br><span class="line"><span class="comment">//通过 ActivityManagerNative.getDefault() 获取到 ActivityManagerService 的代理为进程通讯作准备。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerNative.getDefault().startActivity()</span><br><span class="line">ActivityManagerProxy.startActivity()</span><br><span class="line"><span class="comment">//调用代理对象的 startActivity() 方法，发送 START_ACTIVITY_TRANSACTION 命令。</span></span><br></pre></td></tr></table></figure><p>在 system_server 进程中的服务端 ActivityManagerService 收到 START_ACTIVITY_TRANSACTION 命令后进行处理，调用 startActivity() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.startActivity() -&gt; startActivityAsUser(intent, requestCode, userId)</span><br><span class="line"><span class="comment">//通过 UserHandle.getCallingUserId() 获取到 userId 并调用 startActivityAsUser() 方法。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityMayWait() -&gt; resolveActivity()</span><br><span class="line"><span class="comment">//通过 intent 创建新的 intent 对象，即使之前 intent 被修改也不受影响。 然后调用 resolveActivity()。</span></span><br><span class="line"><span class="comment">//然后通过层层调用获取到 ApplicationPackageManager 对象。</span></span><br><span class="line"></span><br><span class="line">PackageManagerService.resolveIntent() -&gt; queryIntentActivities()</span><br><span class="line"><span class="comment">//获取 intent 所指向的 Activity 信息，并保存到 Intent 对象。</span></span><br><span class="line"></span><br><span class="line">PackageManagerService.chooseBestActivity()</span><br><span class="line"><span class="comment">//当存在多个满足条件的 Activity 则会弹框让用户来选择。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityLocked()</span><br><span class="line"><span class="comment">//获取到调用者的进程信息。 通过 Intent.FLAG_ACTIVITY_FORWARD_RESULT 判断是否需要进行 startActivityForResult 处理。 </span></span><br><span class="line"><span class="comment">//检查调用者是否有权限来调用指定的 Activity。 </span></span><br><span class="line"><span class="comment">//创建 ActivityRecord 对象，并检查是否运行 App 切换。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityUncheckedLocked() -&gt; startActivityLocked()</span><br><span class="line"><span class="comment">//进行对 launchMode 的处理[可参考 Activity 启动模式]，创建 Task 等操作。</span></span><br><span class="line"><span class="comment">//启动 Activity 所在进程，已存在则直接 onResume()，不存在则创建 Activity 并处理是否触发 onNewIntent()。</span></span><br><span class="line"></span><br><span class="line">ActivityStack.resumeTopActivityInnerLocked()</span><br><span class="line"><span class="comment">//找到 resume 状态的 Activity，执行 startPausingLocked() 暂停该 Activity，同时暂停所有处于后台栈的 Activity，找不到 resume 状态的 Activity 则回桌面。</span></span><br><span class="line"><span class="comment">//如果需要启动的 Activity 进程已存在，直接设置 Activity 状态为 resumed。 调用下面方法。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startSpecificActivityLocked()</span><br><span class="line"><span class="comment">//进程存在调用 realStartActivityLocked() 启动 Activity，进程不存在则调用下面方法。</span></span><br></pre></td></tr></table></figure><h2 id="fork-新进程"><a href="#fork-新进程" class="headerlink" title="fork 新进程"></a>fork 新进程</h2><p>从 Launcher 点击图标，如果应用没有启动过，则会 fork 一个新进程。创建新进程的时候，ActivityManagerService 会保存一个 ProcessRecord 信息，Activity 应用程序中的AndroidManifest.xml 配置文件中，我们没有指定 Application 标签的 process 属性，系统就会默认使用 package 的名称。每一个应用程序都有自己的 uid，因此，这里 uid + process 的组合就可以为每一个应用程序创建一个 ProcessRecord。每次在新建新进程前的时候会先判断这个 ProcessRecord 是否已存在，如果已经存在就不会新建进程了，这就属于应用内打开 Activity 的过程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.startProcessLocked()</span><br><span class="line"><span class="comment">//进程不存在请求 Zygote 创建新进程。 创建成功后切换到新进程。</span></span><br></pre></td></tr></table></figure><p>进程创建成功切换至 App 进程，进入 app 进程后将 ActivityThread 类加载到新进程，并调用 ActivityThread.main() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.main()</span><br><span class="line"><span class="comment">//创建主线程的 Looper 对象，创建 ActivityThread 对象，ActivityThread.attach() 建立 Binder 通道，开启 Looper.loop() 消息循环。</span></span><br><span class="line"></span><br><span class="line">ActivityThread.attach()</span><br><span class="line"><span class="comment">//开启虚拟机各项功能，创建 ActivityManagerProxy 对象，调用基于 IActivityManager 接口的 Binder 通道 ActivityManagerProxy.attachApplication()。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerProxy.attachApplication()</span><br><span class="line"><span class="comment">//发送 ATTACH_APPLICATION_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><p>此时只创建了应用程序的 ActivityThread 和 ApplicationThread，和开启了 Handler 消息循环机制，其他的都还未创建， ActivityThread.attach(false) 又会最终到 ActivityMangerService 的 attachApplication，这个工程其实是将本地的 ApplicationThread 传递到 ActivityMangerService。然后 ActivityMangerService 就可以通过 ApplicationThread 的代理 ApplicationThreadProxy 来调用应用程序 ApplicationThread.bindApplication，通知应用程序的 ApplicationThread 已和 ActivityMangerService 绑定，可以不借助其他进程帮助直接通信了。此时 Launcher 的任务也算是完成了。</p><p>在 system_server 进程中的服务端 ActivityManagerService 收到 ATTACH_APPLICATION_TRANSACTION 命令后进行处理，调用 attachApplication()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityMangerService.attachApplication() -&gt; attachApplicationLocked()</span><br><span class="line"><span class="comment">//首先会获取到进程信息 ProcessRecord。 绑定死亡通知，移除进程启动超时消息。 获取到应用 ApplicationInfo 并绑定应用 IApplicationThread.bindApplication(appInfo)。</span></span><br><span class="line"><span class="comment">//然后检查 App 所需组件。</span></span><br></pre></td></tr></table></figure><ul><li>Activity: 检查最顶层可见的 Activity 是否等待在该进程中运行，调用 ActivityStackSupervisor.attachApplicationLocked()。</li><li>Service：寻找所有需要在该进程中运行的服务，调用 ActiveServices.attachApplicationLocked()。</li><li>Broadcast：检查是否在这个进程中有下一个广播接收者，调用 sendPendingBroadcastsLocked()。</li></ul><p>此处讨论 Activity 的启动过程，只讨论 ActivityStackSupervisor.attachApplicationLocked() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityStackSupervisor.attachApplicationLocked() -&gt; realStartActivityLocked()</span><br><span class="line"><span class="comment">//将该进程设置为前台进程 PROCESS_STATE_TOP，调用 ApplicationThreadProxy.scheduleLaunchActivity()。</span></span><br><span class="line"></span><br><span class="line">ApplicationThreadProxy.scheduleLaunchActivity()</span><br><span class="line"><span class="comment">//发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><p>发送送完 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，还会发送 BIND_APPLICATION_TRANSACTION 命令来创建 Application。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationThreadProxy.bindApplication()</span><br><span class="line"><span class="comment">//发送 BIND_APPLICATION_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><h2 id="App-进程初始化"><a href="#App-进程初始化" class="headerlink" title="App 进程初始化"></a>App 进程初始化</h2><p>在 app 进程中，收到 BIND_APPLICATION_TRANSACTION 命令后调用 ActivityThread.bindApplication()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.bindApplication()</span><br><span class="line"><span class="comment">//缓存 Service，初始化 AppBindData，发送消息 H.BIND_APPLICATION。</span></span><br></pre></td></tr></table></figure><p>ApplicationThreadProxy.bindApplication(…) 会传来这个应用的一些信息，如ApplicationInfo，Configuration 等，在 ApplicationThread.bindApplication 里会待信息封装成A ppBindData，通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(H.BIND_APPLICATION, data)</span><br></pre></td></tr></table></figure><p>将信息放到应用里的消息队列里，通过 Handler 消息机制，在 ActivityThread.handleMeaasge 里处理 H.BIND_APPLICATION 的信息，调用 AplicationThread.handleBindApplication。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    Process.setArgV0(data.processName);<span class="comment">//设置进程名</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化 mInstrumentation</span></span><br><span class="line">    <span class="keyword">if</span>(data.mInstrumentation!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Application，data.info 是个 LoadedApk 对象。</span></span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">    mInitialApplication = app;</span><br><span class="line">    <span class="comment">//调用 Application 的 onCreate()方法。</span></span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;   </span><br><span class="line">       <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时新建一个 Application 的 ContextImpl 对象，</span></span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过在 handleBindApplication 创建的 mInstrumentation 对象新建一个 Application 对象，同时进行 attach。</span></span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);</span><br><span class="line">    appContext.setOuterContext(app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置进程名，获取 LoadedApk 对象，创建 ContextImpl 上下文</span></span><br><span class="line"><span class="comment">//LoadedApk.makeApplication() 创建 Application 对象，调用 Application.onCreate() 方法。</span></span><br></pre></td></tr></table></figure><p>Instrumentation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br><span class="line">Instrumentation类：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span>  </span>&#123;</span><br><span class="line">    <span class="comment">//实例化 Application</span></span><br><span class="line">    Application app = (Application)clazz.newInstance();     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Application 和 context绑定</span></span><br><span class="line">    app.attach(context);    </span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//attach 就是将新建的 ContextImpl 赋值到 mBase，这个 ContextImpl 对象就是所有Application 内 Context 的具体实现，同时赋值一些其他的信息如 mLoadedApk。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;    </span><br><span class="line">    mBase = base;  </span><br><span class="line">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时 Application 就创建好了，这点很重要，很多资料里说 Application 是在performLaunchActivity() 里创建的，因为 performLaunchActivity() 也有mInstrumentation.newApplication 这个调用，newApplication() 函数中可看出会先判断是否以及创建了 Application，如果之前已经创建，就返回已创建的 Application 对象。</p><h2 id="Activity-启动"><a href="#Activity-启动" class="headerlink" title="Activity 启动"></a>Activity 启动</h2><p>上面 fork 进程时会发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，在 app 进程中，收到 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令后调用 ApplicationThread.scheduleLaunchActivity()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ApplicationThread.scheduleLaunchActivity()</span><br><span class="line"><span class="comment">//发送消息 H.LAUNCH_ACTIVITY。</span></span><br><span class="line"></span><br><span class="line">sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line"></span><br><span class="line">ActivityThread.handleLaunchActivity()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onConfigurationChanged()，初始化 WindowManagerService。</span></span><br><span class="line"><span class="comment">//调用 ActivityThread.performLaunchActivity()</span></span><br><span class="line"></span><br><span class="line">ActivityThread.performLaunchActivity() &#123;</span><br><span class="line">    <span class="comment">//类似 Application 的创建过程，通过 classLoader 加载到 activity.</span></span><br><span class="line">    activity = mInstrumentation.newActivity(classLoader, </span><br><span class="line">               component.getClassName(), r.intent);</span><br><span class="line">    <span class="comment">//因为 Activity 有界面，所以其 Context 是 ContextThemeWrapper 类型，但实现类仍是ContextImpl.</span></span><br><span class="line">    Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">    activity.attach(context,mInstrumentation,application,...);</span><br><span class="line">    <span class="comment">//与 Window 进行关联</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//attach 后调用 activity 的 onCreate()方法。</span></span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity,...)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在ActivityThread.handleLaunchActivity里，接着调用</span></span><br><span class="line"></span><br><span class="line">Activity.performCreate() -&gt; onCreate()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onCreate()。</span></span><br><span class="line"></span><br><span class="line">Activity.setContentView()</span><br><span class="line"><span class="comment">//设置 layout 布局</span></span><br><span class="line"></span><br><span class="line">ActivityThread.performResumeActivity()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onResume()。</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Activity 的整体启动流程如图所示：</p><img src="/2018/02/01/Android%20Activity启动过程/03.jpg" title="Activity 的整体启动流程"><ul><li>ActivityThread 是什么，它是一个线程吗，如何被启动的？</li></ul><p>它不是一个线程，它是运行在 App 进程中的主线程中的一个方法中。当 App 进程创建时会执行 ActivityThread.main()，ActivityThread.main() 首先会创建 Looper 执行 Looper.prepareMainLooper()；然后创建 ActivityThread 并调用 ActivityThread.attach() 方法告诉 ActivityManagerService 我们创建了一个应用 并将 ApplicationThread 传给 ActivityManagerService；最后调用 Looper.loop()。</p><ul><li>ActivityClientRecord 与 ActivityRecord 是什么？</li></ul><p>记录 Activity 相关信息，比如：Window，configuration，ActivityInfo 等。<br>ActivityClientRecord 是客户端的，ActivityRecord 是 ActivityManagerService 服务端的。</p><ul><li>Context 是什么，ContextImpl，ContextWapper 是什么？</li></ul><p>Context 定义了 App 进程的相关环境，Context 是一个接口，ContextImpl 是子类，ContextWapper 是具体实现。</p><p>应用资源是在 Application 初始化的时候，也就是创建 Application，ContextImpl 的时候，ContextImpl 就包含这个路径，主要就是对就是 ResourcesManager 这个单例的引用。</p><p>可以看出每次创建 Application 和 Acitvity 以及 Service 时就会有一个 ContextImpl 实例，ContentProvider 和B roadcastReceiver 的 Context 是其他地方传入的。</p><p>所以 Context 数量 = Application 数量 + Activity 数量 + Service 数量，单进程情况下 Application 数量就是 1。</p><ul><li>Instrumentation 是什么？</li></ul><p>管理着组件 Application，Activity，Service 等的创建，生命周期调用。</p><ul><li>Application 是什么，什么时候创建的，每个应用程序有几个 Application？</li></ul><p>Application 是在 ActivityThread.handleBindApplication() 中创建的，一个进程只会创建一个 Application，但是一个应用如果有多个进程就会创建多个 Application 对象。</p><ul><li>点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？</li></ul><p>点击 Launcher 时会创建一个新进程来开启 Activity，而应用内打开 Activity，如果 Activity 不指定新进程，将在原来进程打开，是否开启新进程实在 ActivityManagerService 进行控制的，上面分析得到，每次开启新进程时会保存进程信息，默认为 应用包名 + 应用UID，打开 Activity 时会检查请求方的信息来判断是否需要新开进程。Launcher 打开 Activity 默认 ACTIVITY_NEW_TASK，新开一个 Activity 栈来保存 Activity 的信息。</p><ul><li>Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？</li></ul><p>Activity.onCreate() 完成了 App 进程，Application，Activity 的创建，调用 setContentView() 给 Activity 设置了 layout 布局。</p><p>Activity.onResume() 完成了 Activity 中 Window 与 WindowManager 的关联，并对所有子 View 进行渲染并显示。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/6685853/" target="_blank" rel="noopener">Android应用程序的Activity启动过程简要介绍和学习计划</a></li><li><a href="https://silencedut.github.io/2016/08/02/Android%20应用点击图标到Activity界面显示的过程分析/" target="_blank" rel="noopener">Android 应用点击图标到Activity界面显示的过程分析</a></li><li>《深入理解 Android 内核设计思想》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Activity启动过程&quot;&gt;&lt;a href=&quot;#Android-Activity启动过程&quot; class=&quot;headerlink&quot; title=&quot;Android - Activity启动过程&quot;&gt;&lt;/a&gt;Android - Activity启动过程&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Activity" scheme="https://cohleke.github.io/tags/Activity/"/>
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android常见内存泄露分析</title>
    <link href="https://cohleke.github.io/2018/01/21/Android%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%88%86%E6%9E%90/"/>
    <id>https://cohleke.github.io/2018/01/21/Android常见内存泄露分析/</id>
    <published>2018-01-21T15:15:41.000Z</published>
    <updated>2018-03-09T15:31:37.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何找到项目中存在的内存泄露的地方？"><a href="#如何找到项目中存在的内存泄露的地方？" class="headerlink" title="如何找到项目中存在的内存泄露的地方？"></a>如何找到项目中存在的内存泄露的地方？</h1><h2 id="确定是否存在内存泄露"><a href="#确定是否存在内存泄露" class="headerlink" title="确定是否存在内存泄露"></a>确定是否存在内存泄露</h2><h3 id="Android-Monitors的内存分析"><a href="#Android-Monitors的内存分析" class="headerlink" title="Android Monitors的内存分析"></a>Android Monitors的内存分析</h3><p>最直观的看内存增长情况，知道该动作是否发生内存泄露。<br>动作发生之前：GC完后内存1.4M; 动作发生之后：GC完后内存1.6M</p><h3 id="使用MAT内存分析工具"><a href="#使用MAT内存分析工具" class="headerlink" title="使用MAT内存分析工具"></a>使用MAT内存分析工具</h3><p>MAT分析heap的总内存占用大小来初步判断是否存在泄露<br>Heap视图中有一个Type叫做data object，即数据对象，也就是我们的程序中大量存在的类类型的对象。<br>在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，<br>一般情况下，这个值的大小决定了是否会有内存泄漏。<br>我们反复执行某一个操作并同时执行GC排除可以回收掉的内存，注意观察data object的Total Size值，<br>正常情况下Total Size值都会稳定在一个有限的范围内，也就是说由于程序中的的代码良好，没有造成对象不被垃圾回收的情况。<br>反之如果代码中存在没有释放对象引用的情况，随着操作次数的增多Total Size的值会越来越大。<br>那么这里就已经初步判断这个操作导致了内存泄露的情况。</p><h2 id="先找怀疑对象-哪些对象属于泄露的"><a href="#先找怀疑对象-哪些对象属于泄露的" class="headerlink" title="先找怀疑对象(哪些对象属于泄露的)"></a>先找怀疑对象(哪些对象属于泄露的)</h2><p>MAT对比操作前后的hprof来定位内存泄露是泄露了什么数据对象。（这样做可以排除一些对象，不用后面去查看所有被引用的对象是否是嫌疑）<br>快速定位到操作前后所持有的对象哪些是增加了(GC后还是比之前多出来的对象就可能是泄露对象嫌疑犯)<br>技巧：Histogram中还可以对对象进行Group，比如选择Group By Package更方便查看自己Package中的对象信息。</p><h2 id="MAT分析hprof来定位内存泄露的原因所在。-哪个对象持有了上面怀疑出来的发生泄露的对象"><a href="#MAT分析hprof来定位内存泄露的原因所在。-哪个对象持有了上面怀疑出来的发生泄露的对象" class="headerlink" title="MAT分析hprof来定位内存泄露的原因所在。(哪个对象持有了上面怀疑出来的发生泄露的对象)"></a>MAT分析hprof来定位内存泄露的原因所在。(哪个对象持有了上面怀疑出来的发生泄露的对象)</h2><ul><li>Dump出内存泄露“当时”的内存镜像hprof，分析怀疑泄露的类；</li><li>把上面2得出的这些嫌疑犯一个一个排查个遍。步骤：</li><li>进入Histogram，过滤出某一个嫌疑对象类</li><li>然后分析持有此类对象引用的外部对象（在该类上面点击右键List Objects—&gt;with incoming references）</li><li>再过滤掉一些弱引用、软引用、虚引用，因为它们迟早可以被GC干掉不属于内存泄露<br>(在类上面点击右键Merge Shortest Paths to GC Roots—&gt;exclude all phantom/weak/soft etc.references)</li><li>逐个分析每个对象的GC路径是否正常<br>此时就要进入代码分析此时这个对象的引用持有是否合理，这就要考经验和体力了！<br>（比如上课的例子中：旋转屏幕后MainActivity有两个，肯定MainActivity发生泄露了，<br>那谁导致他泄露的呢？原来是我们的CommonUtils类持有了旋转之前的那个MainActivity他，<br>那是否合理？结合逻辑判断当然不合理，由此找到内存泄露根源是CommonUtils类持有了该MainActivity实例造成的。<br>怎么解决？罪魁祸首找到了，怎么解决应该不难了，不同情况解决办法不一样，要靠你的智慧了。）</li></ul><p>context.getapplictioncontext()可以吗？<br>可以！！只要让CommonUtils类不直接只有MainActivity的实例就可以了。</p><p>一般我是最笨的方法解决<br>new出来对象，用完后把它 = null;这样算不算优化<br>假如：方法里面定义的对象，要去管吗？一般不需要管。<br>    自己=null，要自己去控制所有对象的生命周期 判断各种空指针，有点麻烦。<br>    但是在很多时候去想到主动将对象置为null是很好的习惯。</p><p>判断一个应用里面内存泄露避免得很好，怎么看？<br>当app退出的时候，这个进程里面所有的对象应该就都被回收了，尤其是很容易被泄露的（View，Activity）是否还内存当中。<br>可以让app退出以后，查看系统该进程里面的所有的View、Activity对象是否为0.<br>工具：使用AndroidStudio–AndroidMonitor–System Information–Memory Usage查看Objects里面的views和Activity的数量是否为0.<br>命令行模式：</p><h1 id="内存泄露经常出现的例子"><a href="#内存泄露经常出现的例子" class="headerlink" title="内存泄露经常出现的例子"></a>内存泄露经常出现的例子</h1><p>内存泄露(Memory Leak)：<br>    进程中某些对象已经没有使用价值了，但是他们却还可以直接或者间接地被引用到GC Root导致无法回收。<br>    当内存泄露过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM.<br>内存溢出（OOM）：<br>    当应用占用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出。比如：加载大图片。</p><h2 id="静态变量引起的内存泄露"><a href="#静态变量引起的内存泄露" class="headerlink" title="静态变量引起的内存泄露"></a>静态变量引起的内存泄露</h2><p>当调用getInstance时，如果传入的context是Activity的context。只要这个单利没有被释放，那么这个<br>Activity也不会被释放一直到进程退出才会释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CommUtil instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CommUtil</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommUtil <span class="title">getInstance</span><span class="params">(Context mcontext)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">    instance = <span class="keyword">new</span> CommUtil(mcontext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//        else&#123;</span></span><br><span class="line"><span class="comment">//            instance.setContext(mcontext);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="非静态内部类引起内存泄露"><a href="#非静态内部类引起内存泄露" class="headerlink" title="非静态内部类引起内存泄露"></a>非静态内部类引起内存泄露</h2><p>(包括匿名内部类)<br>    错误的示范：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span></span>&#123;<span class="comment">//隐式持有MainActivity实例。MainActivity.this.a</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//int b=a;</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>解决方案：<br>将非静态内部类修改为静态内部类。<br>（静态内部类不会隐式持有外部类）</p><p>当使用软引用或者弱引用的时候，MainActivity难道很容易或者可以被GC回收吗？》<br>GC回收的机制是什么？当MainActivity不被任何的对象引用。<br>虽然Handler里面用的是软引用/弱引用，但是并不意味着不存在其他的对象引用该MainActivity。<br>我连MainActivity都被回收了，那他里面的Handler还玩个屁。</p><h2 id="不需要用的监听未移除会发生内存泄露"><a href="#不需要用的监听未移除会发生内存泄露" class="headerlink" title="不需要用的监听未移除会发生内存泄露"></a>不需要用的监听未移除会发生内存泄露</h2><p>例1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tv.setOnClickListener();<span class="comment">//监听执行完回收对象</span></span><br><span class="line"><span class="comment">//add监听，放到集合里面</span></span><br><span class="line">tv.getViewTreeObserver().addOnWindowFocusChangeListener(<span class="keyword">new</span> ViewTreeObserver.OnWindowFocusChangeListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//监听view的加载，view加载出来的时候，计算他的宽高等。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算完后，一定要移除这个监听</span></span><br><span class="line">        tv.getViewTreeObserver().removeOnWindowFocusChangeListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>例2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SensorManager sensorManager = getSystemService(SENSOR_SERVICE);</span><br><span class="line">   Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);</span><br><span class="line">   sensorManager.registerListener(<span class="keyword">this</span>,sensor,SensorManager.SENSOR_DELAY_FASTEST);</span><br><span class="line">   <span class="comment">//不需要用的时候记得移除监听</span></span><br><span class="line">   sensorManager.unregisterListener(listener);</span><br></pre></td></tr></table></figure></p><h2 id="资源未关闭引起的内存泄露情况"><a href="#资源未关闭引起的内存泄露情况" class="headerlink" title="资源未关闭引起的内存泄露情况"></a>资源未关闭引起的内存泄露情况</h2><p>比如：BroadCastReceiver、Cursor、Bitmap、IO流、自定义属性attribute<br>attr.recycle()回收。<br>当不需要使用的时候，要记得及时释放资源。否则就会内存泄露。</p><h2 id="无限循环动画"><a href="#无限循环动画" class="headerlink" title="无限循环动画"></a>无限循环动画</h2><p>没有在onDestroy中停止动画，否则Activity就会变成泄露对象。<br>比如：轮播图效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何找到项目中存在的内存泄露的地方？&quot;&gt;&lt;a href=&quot;#如何找到项目中存在的内存泄露的地方？&quot; class=&quot;headerlink&quot; title=&quot;如何找到项目中存在的内存泄露的地方？&quot;&gt;&lt;/a&gt;如何找到项目中存在的内存泄露的地方？&lt;/h1&gt;&lt;h2 id=&quot;确
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="内存泄露" scheme="https://cohleke.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="性能优化" scheme="https://cohleke.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android Handler消息机制</title>
    <link href="https://cohleke.github.io/2018/01/07/Android%20Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://cohleke.github.io/2018/01/07/Android Handler消息机制/</id>
    <published>2018-01-07T08:41:27.000Z</published>
    <updated>2018-03-11T08:58:17.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Handler消息机制"><a href="#Android-Handler消息机制" class="headerlink" title="Android-Handler消息机制"></a>Android-Handler消息机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android 的消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper 的工作过程。 Handler 的主要作用是将某个任务切换到 Handler 所在的线程中去执行。</p><h2 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h2><p>Handler工作流程</p><img src="/2018/01/07/Android%20Handler消息机制/01.jpg" title="Handler工作流程"><p>Looper</p><blockquote><p><strong>每个线程中最多只能有一个 Looper 对象</strong>，由 Looper 来管理此线程里的 MessageQueue (消息队列)。</p><p>可以通过 <strong>Looper.myLooper()</strong> 获取当前线程的 Looper 实例，通过 <strong>Looper.getMainLooper()</strong> 获取主（UI）线程的 Looper 实例。</p><p>Lopper 会以无限循环的形式去查找是否有新消息，如果有就处理消息，否则就一直等待着。</p></blockquote><p>Handler</p><blockquote><p>你可以构造 Handler 对象来与 Looper 沟通，通过 <strong>push</strong> 发送新消息到 MessageQueue 里；或者通过 <strong>handleMessage</strong> 接收 Looper 从 MessageQueue 取出来消息。</p></blockquote><p>MessageQueue</p><blockquote><p>MessageQueue是一个消息队列，内部存储了一组消息，以队列的形式对外提供插入和<br>删除的工作，内部采用单链表的数据结构来存储消息列表。</p></blockquote><p>ActivityThread</p><blockquote><p>我们经常提到的主线程，也叫UI线程，它就是 ActivityThread，主线程启动会<strong>默认初始化一个 Looper 并创建 Handler</strong>。</p><p><strong>一个线程中只有一个 Looper 实例，一个 MessageQueue 实例，可以有多个 Handler 实例。</strong></p></blockquote><p>ThreadLocal</p><blockquote><p>一个线程内部的数据存储类，通过它可以在指定线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获得数据。</p><p>对于 Handler 来说，它需要获取当前线程的 Looper ,而 Looper 的作用于就是线程并且不同的线程具有不同的 Looper ，通过 ThreadLocal 可以轻松实现线程中的存取。</p><p>ThreadLocal原理：不同线程访问同一个ThreadLoacl的get方法，ThreadLocal的get方法会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找对应的Value值。</p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>通过上面分析我们知道使用 Handler 之前必须先调用 <strong>Looper.prepare();</strong> 进行初始化，我们先看下 Looper 的源码。</p><h4 id="1-Looper-工作原理"><a href="#1-Looper-工作原理" class="headerlink" title="1. Looper 工作原理"></a>1. Looper 工作原理</h4><p>先看一下 Looper 工作流程</p><img src="/2018/01/07/Android%20Handler消息机制/03.png" title="Looper工作流程"><p>Looper 源码最上面的注释里有一个使用示例如下，可以清晰的看出 Looper 的使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Looper.prepare();<span class="comment">//先初始化 Looper</span></span><br><span class="line">         mHandler = <span class="keyword">new</span> Handler() &#123;<span class="comment">//创建 Handler</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">// process incoming messages here</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         Looper.loop();<span class="comment">//启用 Looper 的 loop 方法开启消息轮询</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接续看一下 Looper 的完整源码，分析下工作过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="comment">//每个线程都会有一个ThreadLocal 用来保存 Looper对象（里面包含了主线程和 MessageQueue）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// 主线程的 Looper</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;<span class="comment">//保存消息队列</span></span><br><span class="line">    <span class="keyword">final</span> Thread mThread;<span class="comment">//保存主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;<span class="comment">//为当前线程创建 Looper</span></span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//一个线程只能有一个 Looper， 否则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//将创建的 Looper 放入 ThreadLocal</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化主线程的 Looper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取主线程的 Looper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> sMainLooper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在当前线程中开启轮询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//从 ThreadLocal 中取出当前线程的 Looper 对象</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//Looper 没有调用 Looper.prepare() 初始化，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//从 Looper 对象中取出消息队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// 不断的取出消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line"><span class="comment">//取出消息的 target (也就是 Handler)，执行分发消息的操作</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();<span class="comment">//消息已经分发，进行回收操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();<span class="comment">//从 ThreadLocal 中取出当前线程的 Looper 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建消息队列</span></span><br><span class="line">        mThread = Thread.currentThread();<span class="comment">//保存当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">false</span>);<span class="comment">//直接退出消息循环，不管是否还有消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">true</span>);<span class="comment">//执行完所有的消息，退出消息循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-MessageQueue-工作原理"><a href="#2-MessageQueue-工作原理" class="headerlink" title="2. MessageQueue 工作原理"></a>2. MessageQueue 工作原理</h4><p>在 Looper 中创建了 MessageQueue，我们接着看下 MessageQueue 是怎么工作的。</p><p>MessageQueue 工作流程</p><img src="/2018/01/07/Android%20Handler消息机制/02.png" title="MessageQueue工作流程"><p>MessageQueue的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line"><span class="comment">//构造函数，quitAllowed 用来标识是否允许退出。</span></span><br><span class="line"><span class="comment">//主线程是不允许退出的（不然会退出整个程序），子线程可以退出。</span></span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再看一下 MessageQueue.enqueueMessage() 的源码，分析下是怎么添加消息的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 如果消息队列里面没有消息，或者消息的执行时间比里面的消息早，就把这条消息设置成第一条消息。</span></span><br><span class="line"><span class="comment">//一般不会出现这种情况，因为系统一定会有很多消息。</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果消息队列里面有消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//找到消息队列里面的最后一条消息</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;<span class="comment">//把消息添加到最后</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了怎么添加消息，我们再看下 MessageQueue.next() 方法是怎么取出消息的，也就是 Looper.loop() 方法中不断取消息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;<span class="comment">//拿到当前的消息队列</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//处理异步的消息，暂不讨论</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//取出一条消息，消息队列往后移动一个</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();<span class="comment">//标记为已使用</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 MessageQueue 是个链表结构，里面保存的是 Message，我们再看下 Message 是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;<span class="comment">//消息类型，标识消息的作用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;<span class="comment">//整型参数1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;<span class="comment">//整型参数2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object obj;<span class="comment">//复杂对象参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Messenger replyTo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IN_USE = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//标记消息已使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** If set message is asynchronous */</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ASYNCHRONOUS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;<span class="comment">//标记消息是否异步</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Flags to clear in the copyFrom method */</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">int</span> flags;<span class="comment">//消息当前标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">long</span> when;<span class="comment">//消息执行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Bundle data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Handler target;<span class="comment">//Handler 用于执行 handleMessage();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Runnable callback;<span class="comment">//消息是一个Runnable</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next;<span class="comment">//下一个消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//控制并发访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//消息池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//消息池数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//消息最大数量</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Handler-工作原理"><a href="#3-Handler-工作原理" class="headerlink" title="3. Handler 工作原理"></a>3. Handler 工作原理</h4><p>在 Message 中我们看到了 target 是一个 Handler，我们看下 Handler 是怎么与 Looper 和 MessageQueue 一起搭配工作的。</p><p>看一下 Handler 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;<span class="comment">//如果消息体是 Runnable 就执行 run()</span></span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果创建 Handler 时传入了 Callback，就执行 Callback 里面的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);<span class="comment">//如果上述两种都没有实现，就执行 handleMessage 的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;<span class="comment">//可以指定关联哪个线程的 Looper</span></span><br><span class="line">        <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程调用的构造方法，主线程已经调用了 Looper.prepareMainLooper();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();<span class="comment">//取出主线程的 Looper</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;<span class="comment">//把 Handler 的 mQueue 指向 Looper 中的 mQueue</span></span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种构造方法，专门给子线程中创建 Handler 时使用的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送 Runnable 消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//一般更新 UI 时发送的消息，延时时间为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送延时消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送指定时间发送的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//把字节传入 Message 中一起发送</span></span><br><span class="line"><span class="comment">//Looper 中需要使用 Handler 来执行 dispatchMessage 方法</span></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-ActivityThread-创建默认的-Handler"><a href="#4-ActivityThread-创建默认的-Handler" class="headerlink" title="4. ActivityThread 创建默认的 Handler"></a>4. ActivityThread 创建默认的 Handler</h4><p>上面说过，ActivityThread 主线程默认是有一个 Handler 的，我们来看一下主线程是怎么创建默认的 Handler 的。</p><p>我们看一下 ActivityThread 类中的 main 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();<span class="comment">//准备一些相关环境，给我们的组件启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();<span class="comment">//初始化主线程 Looper</span></span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();<span class="comment">//开启消息轮询，不断取出消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Activity 可以直接用 runOnUiThread() 来使用默认的 Handler 发送消息，我们来看下它是怎么实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;<span class="comment">//非主线程，发送 Runnable 消息</span></span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//在主线程中直接执行 run()</span></span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-HandlerThread-异步消息处理机制"><a href="#5-HandlerThread-异步消息处理机制" class="headerlink" title="5. HandlerThread 异步消息处理机制"></a>5. HandlerThread 异步消息处理机制</h4><blockquote><ol><li>HandlerThread 继承了 Thread，是一种可以使用 Handler 的 Thread；</li><li>在 run 方法中通过 looper.prepare() 来开启消息循环，这样就可以在 HandlerThread 中创<br>建Handler了；</li><li>外界可以通过一个 Handler 的消息方式来通知 HandlerThread 来执行具体任务；确定不使<br>用之后，可以通过 quit 或 quitSafely 方法来终止线程执行。</li></ol></blockquote><p>先分析一下 HandlerThread 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程的优先级</span></span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="comment">//线程的id</span></span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一个与Handler关联的Looper对象</span></span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="comment">//设置优先级为默认线程</span></span><br><span class="line">        mPriority = android.os.Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可重写方法，Looper.loop之前在线程中需要处理的其他逻辑在这里实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//HandlerThread线程的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程的id</span></span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        <span class="comment">//创建Looper对象</span></span><br><span class="line">        <span class="comment">//这就是为什么我们要在调用线程的start()方法后才能得到Looper(Looper.myLooper不为Null)</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="comment">//同步代码块，当获得mLooper对象后，唤醒所有线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置线程优先级</span></span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        <span class="comment">//Looper.loop之前在线程中需要处理的其他逻辑</span></span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        <span class="comment">//建立了消息循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="comment">//一般执行不到这句，除非quit消息队列</span></span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="comment">//线程死了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步代码块，正好和上面run方法中同步块对应</span></span><br><span class="line">        <span class="comment">//只要线程活着并且mLooper为null，则一直等待</span></span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//退出消息循环</span></span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//退出消息循环</span></span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回线程id</span></span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerThread 使用代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HandlerThread mHandlerThread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mThreadHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mUiHandler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"HandlerWorkThread"</span>);</span><br><span class="line">        <span class="comment">//必须在实例化mThreadHandler之前调运start方法，原因上面源码已经分析了</span></span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        <span class="comment">//将当前mHandlerThread子线程的Looper传入mThreadHandler，使得</span></span><br><span class="line">        <span class="comment">//mThreadHandler的消息队列依赖于子线程（在子线程中执行）</span></span><br><span class="line">        mThreadHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                Log.i(<span class="keyword">null</span>, <span class="string">"在子线程中处理！id="</span>+Thread.currentThread().getId());</span><br><span class="line">                <span class="comment">//从子线程往主线程发送消息</span></span><br><span class="line">                mUiHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mUiHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                Log.i(<span class="keyword">null</span>, <span class="string">"在UI主线程中处理！id="</span>+Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//从主线程往子线程发送消息</span></span><br><span class="line">        mThreadHandler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此 Handler 消息机制的源码已经分析完了，相信你一定明白了 Handler 消息机制。<br><br>一句话，每个线程可以创建一个 Looper ，每个 Looper 轮询着一个 MessageQueue 不断取出消息，有消息则回调给 Handler，Handler 负责向 MessageQueue 中发送消息和处理回调的消息来完成线程之间的转换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Handler消息机制&quot;&gt;&lt;a href=&quot;#Android-Handler消息机制&quot; class=&quot;headerlink&quot; title=&quot;Android-Handler消息机制&quot;&gt;&lt;/a&gt;Android-Handler消息机制&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="Handler" scheme="https://cohleke.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Android Binder进程间通讯</title>
    <link href="https://cohleke.github.io/2017/12/30/Android%20Binder%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://cohleke.github.io/2017/12/30/Android Binder进程间通讯/</id>
    <published>2017-12-30T08:41:27.000Z</published>
    <updated>2018-03-11T08:51:41.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Binder进程间通讯"><a href="#Android-Binder进程间通讯" class="headerlink" title="Android-Binder进程间通讯"></a>Android-Binder进程间通讯</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在学习 Binder 机制，在网上查阅了大量的资料，也看了老罗的 Binder 系列的博客和 Innost 的深入理解 Binder 系列的博客，都是从底层开始讲的，全是 C 代码，虽然之前学过 C 和 C++，然而各种函数之间花式跳转，看的我都怀疑人生。 毫不夸张的讲每看一遍都是新的内容，跟没看过一样。 后来又看到了 Gityuan 的博客看到了一些图解仿佛发现了新大陆。 </p><p>下面就以图解的方式介绍下 Binder 机制，相信你看这篇文章，一定有所收获。</p><h2 id="什么是-Binder？"><a href="#什么是-Binder？" class="headerlink" title="什么是 Binder？"></a>什么是 Binder？</h2><p>Binder 是 Android 系统中进程间通讯（IPC）的一种方式，也是 Android 系统中最重要的特性之一。 Android 中的四大组件 Activity，Service，Broadcast，ContentProvider，不同的 App 等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。</p><p>理解 Binder 对于理解整个 Android 系统有着非常重要的作用，如果对 Binder 不了解，就很难对 Android 系统机制有更深入的理解。</p><h2 id="1-Binder-架构"><a href="#1-Binder-架构" class="headerlink" title="1. Binder 架构"></a>1. Binder 架构</h2><img src="/2017/12/30/Android%20Binder进程间通讯/01.jpg" title="Binder 架构"><ul><li>Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。</li><li>Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 </li><li>Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。</li></ul><h2 id="2-Binder-机制"><a href="#2-Binder-机制" class="headerlink" title="2. Binder 机制"></a>2. Binder 机制</h2><img src="/2017/12/30/Android%20Binder进程间通讯/08.jpg" title="Binder 机制"><ul><li><p>首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。</p></li><li><p>有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取WindowManager服务引用</span></span><br><span class="line">WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE);</span><br></pre></td></tr></table></figure><p>  获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。</p></li><li><p>有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。</p></li></ul><p>怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。</p><h2 id="3-Binder-驱动"><a href="#3-Binder-驱动" class="headerlink" title="3. Binder 驱动"></a>3. Binder 驱动</h2><p>我们先来了解下用户空间与内核空间是怎么交互的。</p><img src="/2017/12/30/Android%20Binder进程间通讯/02.jpg" title="用户空间与内核空间"><p>先了解一些概念</p><h3 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间/内核空间"></a>用户空间/内核空间</h3><p>详细解释可以参考 <a href="http://www.linfo.org/kernel_space.html" target="_blank" rel="noopener">Kernel Space Definition</a>； 简单理解如下：</p><p>Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p><p>Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。</p><h3 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h3><p>虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？</p><blockquote><p>Kernel space can be accessed by user processes only through the use of system calls.</p></blockquote><p>用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。</p><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p><h3 id="内核模块-驱动"><a href="#内核模块-驱动" class="headerlink" title="内核模块/驱动"></a>内核模块/驱动</h3><p>通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p><p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动;</p><blockquote><p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；</p></blockquote><p>驱动就是操作硬件的接口，为了支持 Binder 通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。</p><p>熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。</p><h2 id="4-Binder-进程与线程"><a href="#4-Binder-进程与线程" class="headerlink" title="4. Binder 进程与线程"></a>4. Binder 进程与线程</h2><img src="/2017/12/30/Android%20Binder进程间通讯/03.jpg" title="进程与线程"><p>对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。</p><p>Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。</p><h2 id="5-ServiceManager-启动"><a href="#5-ServiceManager-启动" class="headerlink" title="5. ServiceManager 启动"></a>5. ServiceManager 启动</h2><p>了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。</p><img src="/2017/12/30/Android%20Binder进程间通讯/04.jpg" title="Binder 驱动"><ul><li><p>ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。</p></li><li><p>ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。</p></li><li><p>ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。</p></li></ul><h2 id="6-ServiceManager-注册服务"><a href="#6-ServiceManager-注册服务" class="headerlink" title="6. ServiceManager 注册服务"></a>6. ServiceManager 注册服务</h2><img src="/2017/12/30/Android%20Binder进程间通讯/05.jpg" title="注册服务"><ul><li><p>注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。</p></li><li><p>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。</p></li><li><p>事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。</p></li></ul><h2 id="7-ServiceManager-获取服务"><a href="#7-ServiceManager-获取服务" class="headerlink" title="7. ServiceManager 获取服务"></a>7. ServiceManager 获取服务</h2><img src="/2017/12/30/Android%20Binder进程间通讯/06.jpg" title="获取服务"><ul><li><p>获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。</p></li><li><p>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。</p></li><li><p>Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。</p></li></ul><h2 id="8-进行一次完整通讯"><a href="#8-进行一次完整通讯" class="headerlink" title="8. 进行一次完整通讯"></a>8. 进行一次完整通讯</h2><img src="/2017/12/30/Android%20Binder进程间通讯/07.jpg" title="完整通讯"><ul><li><p>我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。</p></li><li><p>首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给  ServiceManager，同时客户端线程进入等待状态。</p></li><li><p>ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。 努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。</p><p>网上资料很多，个人觉得比较好的如下：</p><ol><li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Bander设计与实现</a></li><li>老罗的 <a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a> 系列</li><li>Innost的 <a href="http://blog.csdn.net/innost/article/details/47208049" target="_blank" rel="noopener">深入理解Binder</a> 系列</li><li>Gityuan的 <a href="http://gityuan.com/2015/10/31/binder-prepare" target="_blank" rel="noopener">Binder系列</a> (基于 Android 6.0)</li><li><a href="http://weishu.me/2016/01/12/binder-index-for-newer" target="_blank" rel="noopener">Binder学习指南</a></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gityuan.com/2015/10/31/binder-prepare" target="_blank" rel="noopener">Binder系列</a></li><li><a href="http://weishu.me/2016/01/12/binder-index-for-newer" target="_blank" rel="noopener">Binder学习指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Binder进程间通讯&quot;&gt;&lt;a href=&quot;#Android-Binder进程间通讯&quot; class=&quot;headerlink&quot; title=&quot;Android-Binder进程间通讯&quot;&gt;&lt;/a&gt;Android-Binder进程间通讯&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="Binder" scheme="https://cohleke.github.io/tags/Binder/"/>
    
  </entry>
  
</feed>
