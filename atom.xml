<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>科长</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cohleke.github.io/"/>
  <updated>2018-12-25T02:32:25.269Z</updated>
  <id>https://cohleke.github.io/</id>
  
  <author>
    <name>科长</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手动实现Quartz集群解决方案（动态增改任务、切换服务器、日志监控等）</title>
    <link href="https://cohleke.github.io/2018/12/18/Quartz%E9%9B%86%E7%BE%A4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E5%8A%A8%E6%80%81%E5%A2%9E%E6%94%B9%E4%BB%BB%E5%8A%A1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%AD%89%EF%BC%89/"/>
    <id>https://cohleke.github.io/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/</id>
    <published>2018-12-18T06:59:41.000Z</published>
    <updated>2018-12-25T02:32:25.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手动实现Quartz集群解决方案"><a href="#手动实现Quartz集群解决方案" class="headerlink" title="手动实现Quartz集群解决方案"></a>手动实现Quartz集群解决方案</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在企业项目应用中必然要集成定时任务，绝大部分JavaEE工程采用Quartz和Spring的相应配置即可完成，若要修改任务的执行时间、执行服务器、任务的启动暂停等操作需要改变配置代码甚至需要重启服务器，本文是集群化服务器下动态的处理定时任务的一个实现。</p><h3 id="本文主要对以下问题分析："><a href="#本文主要对以下问题分析：" class="headerlink" title="本文主要对以下问题分析："></a>本文主要对以下问题分析：</h3><ul><li>Quartz集群原理</li><li>集群化服务器下的任务解决方案</li><li>Quartz原生集群方案的弊端</li><li>自定义实现集群化任务管理</li><li><font color="#DC143C">反射机制手动装载Bean，@Autowired注解注入失败问题</font></li></ul><h3 id="本文将实现以下功能："><a href="#本文将实现以下功能：" class="headerlink" title="本文将实现以下功能："></a>本文将实现以下功能：</h3><ul><li>动态管理定时任务，启动、暂停、修改等</li><li>实时切换任务执行服务器</li><li>任务日志管理，运行监控、报警</li></ul><h3 id="希望读者具备："><a href="#希望读者具备：" class="headerlink" title="希望读者具备："></a>希望读者具备：</h3><ul><li>理解Spring Bean的装配方式与生命周期</li><li>理解Java反射机制</li><li>JavaEE开发经验</li><li>Quartz集成经验</li><li>JavaWeb开发经验</li></ul><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>JDK 1.8+</p><p>Spring版本 3.2 +</p><p>Tomcat 8.5.32</p><p>Quartz版本 2.2.1+</p><p>Gradle3.5+</p><p>MySQL 5.7.9+</p><p>IntelliJ IDEA 2018.2.6</p><p>Gradle中必须引入quartz-jobs</p><pre><code>&apos;org.quartz-scheduler:quartz:2.2.1&apos;, &apos;org.quartz-scheduler:quartz-jobs:2.2.1&apos;, </code></pre><p>Spring配置中引入注册bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;schedulerFactoryBean&quot;</span><br><span class="line">class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot; /&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Quartz基本原理"><a href="#Quartz基本原理" class="headerlink" title="Quartz基本原理"></a>Quartz基本原理</h2><h3 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h3><p>Quartz核心要素有Scheduler、Trigger、Job、JobDetail，其中trigger和job、jobDetail为元数据，而Scheduler为实际进行调度的控制器。</p><ul><li>Trigger</li></ul><p>Trigger用于定义调度任务的时间规则，在Quartz中主要有四种类型的Trigger：SimpleTrigger、CronTrigger、DataIntervalTrigger和NthIncludedTrigger。</p><ul><li>Job&amp;Jodetail</li></ul><p>Quartz将任务分为Job、JobDetail两部分，其中Job用来定义任务的执行逻辑，而JobDetail用来描述Job的定义（例如Job接口的实现类以及其他相关的静态信息）。对Quartz而言，主要有两种类型的Job，StateLessJob、StateFulJob</p><ul><li>Scheduler</li></ul><p>实际执行调度逻辑的控制器，Quartz提供了DirectSchedulerFactory和StdSchedulerFactory等工厂类，用于支持Scheduler相关对象的产生。</p><h3 id="核心元素间关系"><a href="#核心元素间关系" class="headerlink" title="核心元素间关系"></a>核心元素间关系</h3><img src="/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/1-1.png" title="点击 核心元素间关系"><h3 id="主要线程"><a href="#主要线程" class="headerlink" title="主要线程"></a>主要线程</h3><p>在Quartz中，有两类线程，也即执行线程和调度线程，其中执行任务的线程通常用一个线程池维护。线程间关系如下图所示。<br><img src="/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/1-2.png" title="点击 线程间关系"></p><p>在quartz中，Scheduler调度线程主要有两个：regular Scheduler Thread（执行常规调度）和Misfire Scheduler Thread（执行错失的任务）。其中Regular Thread 轮询Trigger，如果有将要触发的Trigger，则从任务线程池中获取一个空闲线程，然后执行与改Trigger关联的job；Misfire Thraed则是扫描所有的trigger，查看是否有错失的，如果有的话，根据一定的策略进行处理。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>Quartz中的trigger和job需要存储下来才能被使用。Quartz中有两种存储方式：RAMJobStore,JobStoreSupport，其中RAMJobStore是将trigger和job存储在内存中，而JobStoreSupport是基于jdbc将trigger和job存储到数据库中。RAMJobStore的存取速度非常快，但是由于其在系统被停止后所有的数据都会丢失，所以在集群应用中，必须使用JobStoreSupport。其中表结构如下表所示。</p><table><thead><tr><th style="text-align:left">Table name</th><th style="text-align:right">Description</th></tr></thead><tbody><tr><td style="text-align:left">QRTZ_CALENDARS</td><td style="text-align:right">存储Quartz的Calendar信息</td></tr><tr><td style="text-align:left">QRTZ_CRON_TRIGGERS</td><td style="text-align:right">存储CronTrigger，包括Cron表达式和时区信息</td></tr><tr><td style="text-align:left">QRTZ_FIRED_TRIGGERS</td><td style="text-align:right">存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td></tr><tr><td style="text-align:left">QRTZ_PAUSED_TRIGGER_GRPS</td><td style="text-align:right">存储已暂停的Trigger组的信息</td></tr><tr><td style="text-align:left">QRTZ_SCHEDULER_STATE</td><td style="text-align:right">存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td></tr><tr><td style="text-align:left">QRTZ_LOCKS</td><td style="text-align:right">存储程序的悲观锁的信息</td></tr><tr><td style="text-align:left">QRTZ_JOB_DETAILS</td><td style="text-align:right">存储每一个已配置的Job的详细信息</td></tr><tr><td style="text-align:left">QRTZ_SIMPLE_TRIGGERS</td><td style="text-align:right">存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td></tr><tr><td style="text-align:left">QRTZ_BLOG_TRIGGERS</td><td style="text-align:right">Trigger作为Blob类型存储</td></tr><tr><td style="text-align:left">QRTZ_TRIGGERS</td><td style="text-align:right">存储已配置的Trigger的信息</td></tr><tr><td style="text-align:left">QRTZ_SIMPROP_TRIGGERS</td></tr></tbody></table><h3 id="Quartz原生集群支持"><a href="#Quartz原生集群支持" class="headerlink" title="Quartz原生集群支持"></a>Quartz原生集群支持</h3><p>一个Quartz集群中的每个节点是一个独立的Quartz应用，它又管理着其他的节点。这就意味着你必须对每个节点分别启动或停止。Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的。<br><img src="/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/1-3.png" title="点击 原生集群支持"></p><h3 id="原生集群支持的问题"><a href="#原生集群支持的问题" class="headerlink" title="原生集群支持的问题"></a>原生集群支持的问题</h3><p>原生集群支持需要在数据库新增十二张表，且每个任务调度是随机分配服务器，加上部分任务执行时间过长可能超时报错等等原因，可定制程度不高，固未采用原生集群方案。下面开始手写方案。</p><h2 id="自定义实现集群化任务管理"><a href="#自定义实现集群化任务管理" class="headerlink" title="自定义实现集群化任务管理"></a>自定义实现集群化任务管理</h2><p>先展示成果</p><img src="/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/2-1.png" title="点击 管理首页"><h3 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h3><ul><li>创建任务信息表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   CREATE TABLE `t_quartz_job` (</span><br><span class="line">  `job_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;任务ID&apos;,</span><br><span class="line">  `create_time` timestamp NULL DEFAULT NULL COMMENT &apos;创建时间&apos;,</span><br><span class="line">  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;修改时间&apos;,</span><br><span class="line">  `job_name` varchar(255) DEFAULT NULL COMMENT &apos;任务名&apos;,</span><br><span class="line">  `job_group` varchar(255) DEFAULT NULL COMMENT &apos;任务组&apos;,</span><br><span class="line">  `job_status` varchar(255) DEFAULT NULL COMMENT &apos;任务状态&apos;,</span><br><span class="line">  `cron_expression` varchar(255) NOT NULL COMMENT &apos;时间表达式&apos;,</span><br><span class="line">  `description` varchar(255) DEFAULT NULL COMMENT &apos;描述&apos;,</span><br><span class="line">  `bean_class` varchar(255) NOT NULL COMMENT &apos;bean&apos;,</span><br><span class="line">  `is_concurrent` varchar(255) DEFAULT NULL COMMENT &apos;1&apos;,</span><br><span class="line">  `spring_id` varchar(255) DEFAULT NULL COMMENT &apos;spring&apos;,</span><br><span class="line">  `method_name` varchar(255) NOT NULL COMMENT &apos;方法名&apos;,</span><br><span class="line">  `allowed_ip` varchar(50) NOT NULL COMMENT &apos;允许执行定时任务的服务器IP&apos;,</span><br><span class="line">  PRIMARY KEY (`job_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><ul><li>创建保存任务信息的实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobDetail</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正在运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATUS_RUNNING = <span class="string">"1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATUS_NOT_RUNNING = <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONCURRENT_IS = <span class="string">"1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非同步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONCURRENT_NOT = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">private</span> Long jobId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String jobName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String jobGroup;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务状态 是否启动任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String jobStatus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cron表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String cronExpression;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务执行时调用哪个类的方法 包名+类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String beanClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务是否有状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String isConcurrent;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * spring bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String springId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务调用的方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateTime</span><span class="params">(String createTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUpdateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> updateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpdateTime</span><span class="params">(String updateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.updateTime = updateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIp</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getJobId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobId</span><span class="params">(Long jobId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jobId = jobId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getJobName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobName</span><span class="params">(String jobName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jobName = jobName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getJobGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobGroup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobGroup</span><span class="params">(String jobGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jobGroup = jobGroup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getJobStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobStatus</span><span class="params">(String jobStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jobStatus = jobStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCronExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cronExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCronExpression</span><span class="params">(String cronExpression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cronExpression = cronExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(String beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIsConcurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isConcurrent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsConcurrent</span><span class="params">(String isConcurrent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isConcurrent = isConcurrent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSpringId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> springId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpringId</span><span class="params">(String springId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.springId = springId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实体类对应数据库中的表，jobName 与 groupName的组合是唯一的,beanClass/springId至少一个不为空。</p><h3 id="新增批次"><a href="#新增批次" class="headerlink" title="新增批次"></a>新增批次</h3><img src="/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/2-2.png" title="点击 新增批次"><ul><li><p>前端代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//获取模态框数据</span></span><br><span class="line">        <span class="keyword">var</span> description = $(<span class="string">'#addDescription'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> cronExpression = $(<span class="string">'#AddCronExpression'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> jobName = $(<span class="string">'#AddName'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> jobGroup = $(<span class="string">'#AddGroup'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> jobStatus = $(<span class="string">'#AddStatus'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> beanClass = $(<span class="string">'#AddClass'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> methodName = $(<span class="string">'#AddMethodName'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> ip = $(<span class="string">'#addIp'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> id = $(<span class="string">'#addId'</span>).val();</span><br><span class="line">        <span class="keyword">var</span> params = &#123;</span><br><span class="line">            jobName: jobName,</span><br><span class="line">            jobGroup: jobGroup,</span><br><span class="line">            jobStatus: jobStatus,</span><br><span class="line">            beanClass: beanClass,</span><br><span class="line">            methodName: methodName,</span><br><span class="line">            description: description,</span><br><span class="line">            cronExpression: cronExpression,</span><br><span class="line">            ip: ip,</span><br><span class="line">            jobId: id</span><br><span class="line">        &#125;;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">"post"</span>,</span><br><span class="line">            url: <span class="string">"job/add-task.do"</span>,</span><br><span class="line">            data: <span class="built_in">JSON</span>.stringify(params),</span><br><span class="line">            dataType: <span class="string">'json'</span>,</span><br><span class="line">            contentType: <span class="string">'application/json;charset=UTF-8'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">                consoleLog(result)</span><br><span class="line">                <span class="keyword">if</span> (result.status === <span class="number">0</span>) &#123;</span><br><span class="line">                    modals.info(<span class="string">'新增成功'</span>);</span><br><span class="line">                    userTable.reloadData();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    modals.info(<span class="string">'新增异常，请联系管理员'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                $(<span class="string">'#myModalAdd'</span>).modal(</span><br><span class="line">                    <span class="string">'hide'</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>MyBatis 插入映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertJob"</span> <span class="attr">parameterType</span>=<span class="string">"JobDetail"</span>&gt;</span></span><br><span class="line">insert into t_quartz_job</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"jobId != null"</span>&gt;</span></span><br><span class="line">job_id,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"createTime != null"</span>&gt;</span></span><br><span class="line">create_time,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"updateTime != null"</span>&gt;</span></span><br><span class="line">update_time,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"jobName != null"</span>&gt;</span></span><br><span class="line">job_name,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"jobGroup != null"</span>&gt;</span></span><br><span class="line">job_group,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"jobStatus != null"</span>&gt;</span></span><br><span class="line">job_status,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"cronExpression != null"</span>&gt;</span></span><br><span class="line">cron_expression,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"description != null"</span>&gt;</span></span><br><span class="line">description,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"beanClass != null"</span>&gt;</span></span><br><span class="line">bean_class,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"isConcurrent != null"</span>&gt;</span></span><br><span class="line">is_concurrent,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"springId != null"</span>&gt;</span></span><br><span class="line">spring_id,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"methodName != null"</span>&gt;</span></span><br><span class="line">method_name,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ip != null"</span>&gt;</span></span><br><span class="line">ip,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"values ("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"jobId != null"</span>&gt;</span></span><br><span class="line">#&#123;jobId,jdbcType=BIGINT&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"createTime != null"</span>&gt;</span></span><br><span class="line">#&#123;createTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"updateTime != null"</span>&gt;</span></span><br><span class="line">#&#123;updateTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"jobName != null"</span>&gt;</span></span><br><span class="line">#&#123;jobName,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"jobGroup != null"</span>&gt;</span></span><br><span class="line">#&#123;jobGroup,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"jobStatus != null"</span>&gt;</span></span><br><span class="line">#&#123;jobStatus,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"cronExpression != null"</span>&gt;</span></span><br><span class="line">#&#123;cronExpression,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"description != null"</span>&gt;</span></span><br><span class="line">#&#123;description,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"beanClass != null"</span>&gt;</span></span><br><span class="line">#&#123;beanClass,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"isConcurrent != null"</span>&gt;</span></span><br><span class="line">#&#123;isConcurrent,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"springId != null"</span>&gt;</span></span><br><span class="line">#&#123;springId,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"methodName != null"</span>&gt;</span></span><br><span class="line">#&#123;methodName,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ip != null"</span>&gt;</span></span><br><span class="line">#&#123;ip,jdbcType=VARCHAR&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="立即运行一次"><a href="#立即运行一次" class="headerlink" title="立即运行一次"></a>立即运行一次</h3><p>考虑到服务器不同配置。可自定义端口。</p><img src="/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/2-5.png" title="点击 立即运行一次"><ul><li><p>后端需做端口字段判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">runJobOnce</span><span class="params">(String json)</span> </span>&#123;</span><br><span class="line">    JSONObject requestJson = JSON.parseObject(json);</span><br><span class="line">    String port = requestJson.getString(<span class="string">"runOncePort"</span>);</span><br><span class="line">    String ip = requestJson.getString(<span class="string">"runOnceIp"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(port)) &#123;</span><br><span class="line">            result = HttpClientUtils.sendPostToMidServer(<span class="string">"http://"</span> + ip + <span class="string">"/"</span> + <span class="string">"run-job-now.do"</span>, json);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = HttpClientUtils.sendPostToMidServer(<span class="string">"http://"</span> + ip + <span class="string">":"</span> + port + <span class="string">"/"</span> + <span class="string">"run-job-now.do"</span>, json);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JSONObject jsonObject = JSON.parseObject(result);</span><br><span class="line">        <span class="keyword">return</span> (jsonObject != <span class="keyword">null</span> &amp;&amp; jsonObject.containsKey(<span class="string">"success"</span>) &amp;&amp; jsonObject.getBooleanValue(<span class="string">"success"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;runJobOnce&gt;&gt;&gt;&gt;&gt;&gt;exception&gt;&gt;&gt;&gt;&#123;&#125;"</span>, e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后端反射运行批次任务，并对IP检验</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokMethod</span><span class="params">(JobDetail scheduleJob)</span> </span>&#123;</span><br><span class="line">    String ip = getLocalHostIP();</span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    Class clazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ip.equals(scheduleJob.getIp())) &#123;</span><br><span class="line">        log.error(<span class="string">"任务名称 = ["</span> + scheduleJob.getJobName() + <span class="string">"]---------------未启动成功，不在执行IP范围！！！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(scheduleJob.getSpringId())) &#123;</span><br><span class="line">        object = SpringUtils.getBean(scheduleJob.getSpringId());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isNotBlank(scheduleJob.getBeanClass())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(scheduleJob.getBeanClass());</span><br><span class="line">            object = clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.error(<span class="string">"任务名称 = ["</span> + scheduleJob.getJobName() + <span class="string">"]---------------未启动成功，请检查是否配置正确！！！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    clazz = object.getClass();</span><br><span class="line">    Method method = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method = clazz.getDeclaredMethod(scheduleJob.getMethodName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        log.error(<span class="string">"任务名称 = ["</span> + scheduleJob.getJobName() + <span class="string">"]---------------未启动成功，方法名设置错误！！！"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"任务名称 = ["</span> + scheduleJob.getJobName() + <span class="string">"]----------启动成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射机制手动装载Bean，-Autowired注解注入失败问题"><a href="#反射机制手动装载Bean，-Autowired注解注入失败问题" class="headerlink" title="反射机制手动装载Bean，@Autowired注解注入失败问题"></a>反射机制手动装载Bean，@Autowired注解注入失败问题</h2><h3 id="Spring的三种装配Bean的方式"><a href="#Spring的三种装配Bean的方式" class="headerlink" title="Spring的三种装配Bean的方式"></a>Spring的三种装配Bean的方式</h3><ul><li>在XML中显式配置</li><li>在Java的接口和类中实现配置</li><li>隐式Bean的发现机制和自动装配原则</li></ul><p>在现实工作中，以上三种方式都会被用到，并且在工作总常常混合使用，所以需要知道三种方式的优先级，也就是应该选择合适的方式把Bean装配到Spring IoC容器中。</p><ul><li>基于约定优于配置原则，最优先的应该是通过隐式Bean的发现机制和自动装配的原则。这样的好处是减少程序开发则的决定权，简单又不失灵活。</li><li>在没有办法使用自动装配原则的情况下，应该优先考虑Java接口和类中实现配置，这样的好处就是避免XML配置泛滥，也更为容易。</li><li>在上述方法都无法使用的情况下，那么只能选择XML去显式配置Spring IoC容器。</li></ul><h3 id="反射机制装载Bean的问题"><a href="#反射机制装载Bean的问题" class="headerlink" title="反射机制装载Bean的问题"></a>反射机制装载Bean的问题</h3><img src="/2018/12/18/Quartz集群解决方案（动态增改任务、服务器、日志监控等）/3-1.png" title="点击 反射装载的问题"><p>如上图所示，反射出来的东西，里面@Autowired注入的组件都是null。</p><p>究其原因是：通过反射创建实例时，是根据你调用的构造函数完成的实例化过程，Spring容器并不知晓，故不会自动化创建实例。因此需要自己对依赖对象进行注入。</p><p>处理方式有两种，还是基于上文：</p><ul><li>在XML中显式配置 </li></ul><figure class="highlight plain"><figcaption><span>id</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- @PostConstruct注解方式</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">@Component </span><br><span class="line">public class TestUtils &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ItemService itemService;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private ItemMapper itemMapper;</span><br><span class="line">    </span><br><span class="line">    public static TestUtils testUtils;</span><br><span class="line">    </span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;    </span><br><span class="line">        testUtils = this;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    //utils工具类中使用service和mapper接口的方法例子，用&quot;testUtils.xxx.方法&quot; 就可以了      </span><br><span class="line">    public static void test(Item record)&#123;</span><br><span class="line">        testUtils.itemMapper.insert(record);</span><br><span class="line">        testUtils.itemService.queryAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结论：<font color="#DC143C">依赖Spring容器实例化与自己用反射实例化是两种各自独立的方式，互不干涉。</font></p><h2 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;手动实现Quartz集群解决方案&quot;&gt;&lt;a href=&quot;#手动实现Quartz集群解决方案&quot; class=&quot;headerlink&quot; title=&quot;手动实现Quartz集群解决方案&quot;&gt;&lt;/a&gt;手动实现Quartz集群解决方案&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="JavaEE" scheme="https://cohleke.github.io/categories/JavaEE/"/>
    
    
      <category term="JavaEE" scheme="https://cohleke.github.io/tags/JavaEE/"/>
    
      <category term="Spring" scheme="https://cohleke.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法kotlin实现</title>
    <link href="https://cohleke.github.io/2018/04/21/kotlin/"/>
    <id>https://cohleke.github.io/2018/04/21/kotlin/</id>
    <published>2018-04-21T12:52:03.000Z</published>
    <updated>2018-05-08T02:51:59.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用排序算法kotlin实现"><a href="#常用排序算法kotlin实现" class="headerlink" title="常用排序算法kotlin实现"></a>常用排序算法kotlin实现</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="kotlin版"><a href="#kotlin版" class="headerlink" title="kotlin版"></a>kotlin版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         平均O(n^2)最坏O(n^2)最优O(n) 辅助空间O(1)  稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">bubbleSort</span><span class="params">(sortList: IntArray)</span> </span>&#123;</span><br><span class="line">    var didSwap: Boolean</span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until sortList.size - <span class="number">1</span>) &#123;</span><br><span class="line">        didSwap = <span class="keyword">false</span></span><br><span class="line">        <span class="keyword">for</span> (j in <span class="number">0</span> until sortList.size - <span class="number">1</span> - i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sortList[j] &gt; sortList[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swapByIndex(sortList, j, j + <span class="number">1</span>)</span><br><span class="line">                didSwap = <span class="keyword">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!didSwap) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java版"><a href="#Java版" class="headerlink" title="Java版"></a>Java版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         平均O(n^2)最坏O(n^2)最优O(n) 辅助空间O(1)  稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swapByIndex(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="kotlin版-1"><a href="#kotlin版-1" class="headerlink" title="kotlin版"></a>kotlin版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *          平均O(n log n)最优O(n log n)最坏O(n^2) 辅助空间O(log n)~ O(n) 不稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">quickSort</span><span class="params">(sortList: IntArray)</span> </span>&#123;</span><br><span class="line">    loopForQuickSort(sortList, <span class="number">0</span>, sortList.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">loopForQuickSort</span><span class="params">(list: IntArray, start: Int, end: Int)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    val k = partition(list, start, end)</span><br><span class="line">    loopForQuickSort(list, start, k - <span class="number">1</span>)</span><br><span class="line">    loopForQuickSort(list, k + <span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">partition</span><span class="params">(list: IntArray, begin: Int, end: Int)</span>: Int </span>&#123;</span><br><span class="line">    val x = list[end]</span><br><span class="line">    var i = begin - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j in begin until end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[j] &lt;= x) &#123;</span><br><span class="line">            i++</span><br><span class="line">            swapByIndex(list, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swapByIndex(list, end, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java版-1"><a href="#Java版-1" class="headerlink" title="Java版"></a>Java版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *          平均O(n log n)最优O(n log n)最坏O(n^2) 辅助空间O(log n)~ O(n) 不稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = partition(arr, begin, end);</span><br><span class="line">    quickSort(arr, begin, k - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, k + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = arr[end];</span><br><span class="line">    <span class="keyword">int</span> i = begin - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; end; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= x) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swapByIndex(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swapByIndex(arr, end, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="kotlin版-2"><a href="#kotlin版-2" class="headerlink" title="kotlin版"></a>kotlin版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/***</span></span><br><span class="line"><span class="comment"> *         平均O(n^2)最坏O(n^2)最优O(n^2) 辅助空间O(1) 不稳定</span></span><br><span class="line"><span class="comment"> *         效率差，但是可以用在“取出数列中最大/最小的几个值”的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">selectionSort</span><span class="params">(sortList: IntArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span>..sortList.size - <span class="number">2</span>) &#123;</span><br><span class="line">        var minIndex = i</span><br><span class="line">        <span class="keyword">for</span> (j in i + <span class="number">1</span> until sortList.size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sortList[minIndex] &gt; sortList[j]) &#123;</span><br><span class="line">                <span class="comment">//找到比较小的值的索引</span></span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swapByIndex(sortList, i, minIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java版-2"><a href="#Java版-2" class="headerlink" title="Java版"></a>Java版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/***</span></span><br><span class="line"><span class="comment"> *         平均O(n^2)最坏O(n^2)最优O(n^2) 辅助空间O(1) 不稳定</span></span><br><span class="line"><span class="comment"> *         效率差，但是可以用在“取出数列中最大/最小的几个值”的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            swapByIndex(arr, minIndex, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="kotlin版-3"><a href="#kotlin版-3" class="headerlink" title="kotlin版"></a>kotlin版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *       平均O(n^2)最坏O(n^2)最优O(n) 辅助空间O(1) 稳定</span></span><br><span class="line"><span class="comment"> *       可以解决两个有序列表的合并问题，将第二个序列放在第一个序列后面，进行选择插入排序即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">insertSort</span><span class="params">(sortList: IntArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">1</span> until sortList.size) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j in i downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sortList[j] &gt; sortList[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//已经找到当前元素要插入的位置</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            swapByIndex(sortList, j - <span class="number">1</span>, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java版-3"><a href="#Java版-3" class="headerlink" title="Java版"></a>Java版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *       平均O(n^2)最坏O(n^2)最优O(n) 辅助空间O(1) 稳定</span></span><br><span class="line"><span class="comment"> *       可以解决两个有序列表的合并问题，将第二个序列放在第一个序列后面，进行选择插入排序即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                swapByIndex(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="kotlin版-4"><a href="#kotlin版-4" class="headerlink" title="kotlin版"></a>kotlin版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">  *         平均O(n log n)最坏O(n log^2 n)最优O(n log^2 n) 辅助空间O(1) 不稳定</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> fun <span class="title">shellSort</span><span class="params">(sortList: IntArray)</span> </span>&#123;</span><br><span class="line">     var gap = <span class="number">1</span></span><br><span class="line">     <span class="keyword">while</span> (gap &lt; sortList.size / <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="comment">//寻找合适的步长</span></span><br><span class="line">         gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (i in gap until sortList.size) &#123;</span><br><span class="line">             val temp = sortList[i]</span><br><span class="line">             var j = i - gap</span><br><span class="line">             <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//将以temp为元素起点，以gap为步进长度构成的list进行插入运算</span></span><br><span class="line">                 <span class="keyword">if</span> (sortList[j] &lt;= temp) &#123;</span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 sortList[j + gap] = sortList[j]</span><br><span class="line">                 j -= gap</span><br><span class="line">             &#125;</span><br><span class="line">             sortList[j + gap] = temp</span><br><span class="line">         &#125;</span><br><span class="line">         gap /= <span class="number">3</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Java版-4"><a href="#Java版-4" class="headerlink" title="Java版"></a>Java版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">  *         平均O(n log n)最坏O(n log^2 n)最优O(n log^2 n) 辅助空间O(1) 不稳定</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> incre = length;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         incre = incre / <span class="number">2</span>;</span><br><span class="line">         <span class="comment">//对分组进行遍历</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; incre; i++) &#123;</span><br><span class="line">             <span class="comment">//插入排序</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = i + incre; j &lt; length; j += incre) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &gt; i; k -= incre) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (arr[k] &lt; arr[k - incre]) &#123;</span><br><span class="line">                         swapByIndex(arr, k, k - incre);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//无法分组，表示排序结束</span></span><br><span class="line">         <span class="keyword">if</span> (incre == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="kotlin版-5"><a href="#kotlin版-5" class="headerlink" title="kotlin版"></a>kotlin版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *         平均O(n log n)最坏O(n log n)最优O(n log n) 辅助空间O(1) 不稳定</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">heapSort</span><span class="params">(sortList: IntArray)</span> </span>&#123;</span><br><span class="line">    val len = sortList.size</span><br><span class="line">    <span class="keyword">for</span> (i in len / <span class="number">2</span> - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这一步的作用就是建立最大堆模型</span></span><br><span class="line">        <span class="comment">//这里选出来的i，就是当前堆的最后一个三角的单位中的爸爸，也就是说从最后一个单元开始向上递增构建最大堆</span></span><br><span class="line">        loopForHeap(sortList, i, len)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i in len - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//依次拿出堆顶元素放在数列最后</span></span><br><span class="line">        swapByIndex(sortList, <span class="number">0</span>, i)</span><br><span class="line">        <span class="comment">//对剩余的0--&gt;i的堆重拍，即可找到剩余数列中的最大值</span></span><br><span class="line">        loopForHeap(sortList, <span class="number">0</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> fun <span class="title">loopForHeap</span><span class="params">(list: IntArray, start: Int, end: Int)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    val dad = start</span><br><span class="line">    var son = dad * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (son &gt;= end) &#123;</span><br><span class="line">        <span class="comment">//儿子索引已经超过数组最大索引</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son + <span class="number">1</span> &lt; end &amp;&amp; list[son] &lt; list[son + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">//说明两个儿子之间右边的更大</span></span><br><span class="line">        son++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list[dad] &lt;= list[son]) &#123;</span><br><span class="line">        <span class="comment">//交换父子</span></span><br><span class="line">        swapByIndex(list, dad, son)</span><br><span class="line">        <span class="comment">//因为父子交换了，因此该分支下面所有堆都要重排</span></span><br><span class="line">        <span class="comment">//并且索引从当前换位的son开始直到该分支最后一位元素</span></span><br><span class="line">        loopForHeap(list, son, end)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java版-5"><a href="#Java版-5" class="headerlink" title="Java版"></a>Java版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *         平均O(n log n)最坏O(n log n)最优O(n log n) 辅助空间O(1) 不稳定</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MinHeap_Sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    MakeMinHeap(a, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swapByIndex(arr, <span class="number">0</span>, i);</span><br><span class="line">        MinHeapFixdown(a, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MakeMinHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从倒数第二层开始排序，取自己的孩子进行排序，这样所有的节点都排序到了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        MinHeapFixdown(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MinHeapFixdown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//j&lt;n：如果左节点小于节点总数，表示该节点有节点，否则该节点是叶子节点是不需要调整的</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">        <span class="comment">//j+1&lt;n：存在右节点，a[j+1]&lt;a[j]：左右子节点中寻找最小的</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; a[j + <span class="number">1</span>] &lt; a[j]) &#123;</span><br><span class="line">            <span class="comment">//将节点移到右节点</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//较大节点在下面</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//较大节点在上面，则将大节点下移</span></span><br><span class="line">        swapByIndex(arr, i, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复位</span></span><br><span class="line">        i = j;</span><br><span class="line">        j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="kotlin版-6"><a href="#kotlin版-6" class="headerlink" title="kotlin版"></a>kotlin版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *         平均O(d*(n+r))最坏O(d*(n+r))最优O(d*(n+r)) 辅助空间O(n+r) 稳定</span></span><br><span class="line"><span class="comment"> *         d 为位数，r 为基数，n 为原数组个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">radixSort</span><span class="params">(sortList: IntArray)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//寻找当前序列中的最大值，目的是计算最大的位数</span></span><br><span class="line">    var max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until sortList.size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sortList[i] &gt; max) &#123;</span><br><span class="line">            <span class="comment">//找到当前序列最大数</span></span><br><span class="line">            max = sortList[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过最大数找到最大数的位数</span></span><br><span class="line">    val maxDigit = max.toString().length</span><br><span class="line">    var mod = <span class="number">10</span></span><br><span class="line">    var dev = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until maxDigit) &#123;</span><br><span class="line">        val counter = mutableMapOf&lt;Int, ArrayList&lt;Int&gt;&gt;()</span><br><span class="line">        <span class="keyword">for</span> (j in <span class="number">0</span> until sortList.size) &#123;</span><br><span class="line">            <span class="comment">// 取出某个数的第mod位的值</span></span><br><span class="line">            <span class="comment">// 比如数字123，123%100=23,23继续计算23/10=2，最终拿到123的中间位数字</span></span><br><span class="line">            val bucket = (sortList[j] % mod) / dev</span><br><span class="line">            <span class="comment">//按照当前位数作为key以此存入counter的map中</span></span><br><span class="line">            <span class="keyword">if</span> (counter[bucket] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                counter[bucket] = ArrayList&lt;Int&gt;()</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket]?.add(sortList[j])</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i in <span class="number">0</span>..<span class="number">9</span>) &#123;</span><br><span class="line">            <span class="comment">//这里一定使用0--9的索引，因为对counter来说，里面的map的key只能是这个组合，并且一定要按照从0到9的顺序弹出</span></span><br><span class="line">            counter[i]?.forEach &#123;</span><br><span class="line">                <span class="comment">//依次将counter中的值放入列表中</span></span><br><span class="line">                <span class="comment">//第一次经过进--出的操作就对个位数字进行了排序</span></span><br><span class="line">                <span class="comment">//第二次经过进--出的操作就对十位进行了排序</span></span><br><span class="line">                <span class="comment">//经过上面两次排序，就达到了个位+十位的综合排序，也就完成了两位数字的整体排序</span></span><br><span class="line">                sortList[pos++] = it</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dev *= <span class="number">10</span></span><br><span class="line">        mod *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java版-6"><a href="#Java版-6" class="headerlink" title="Java版"></a>Java版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *         平均O(d*(n+r))最坏O(d*(n+r))最优O(d*(n+r)) 辅助空间O(n+r) 稳定</span></span><br><span class="line"><span class="comment"> *         d 为位数，r 为基数，n 为原数组个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;<span class="comment">//代表位数对应的数：1,10,100...</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class="line">    <span class="keyword">int</span> length = array.length;</span><br><span class="line">    <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][length];<span class="comment">//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span></span><br><span class="line">    <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[length];<span class="comment">//用于保存每个桶里有多少个数字</span></span><br><span class="line">    <span class="keyword">while</span> (n &lt; d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) <span class="comment">//将数组array里的每个数字放在相应的桶里</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = (num / n) % <span class="number">10</span>;</span><br><span class="line">            bucket[digit][order[digit]] = num;</span><br><span class="line">            order[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (order[i] != <span class="number">0</span>)<span class="comment">//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++) &#123;</span><br><span class="line">                    array[k] = bucket[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            order[i] = <span class="number">0</span>;<span class="comment">//将桶里计数器置0，用于下一次位排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        n *= <span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>;<span class="comment">//将k置0，用于下一轮保存位排序结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交换位置"><a href="#交换位置" class="headerlink" title="交换位置"></a>交换位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">swapByIndex</span><span class="params">(list: IntArray, x: Int, y: Int)</span> </span>&#123;</span><br><span class="line">    val temp = list[x]</span><br><span class="line">    list[x] = list[y]</span><br><span class="line">    list[y] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用排序算法kotlin实现&quot;&gt;&lt;a href=&quot;#常用排序算法kotlin实现&quot; class=&quot;headerlink&quot; title=&quot;常用排序算法kotlin实现&quot;&gt;&lt;/a&gt;常用排序算法kotlin实现&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒
      
    
    </summary>
    
      <category term="Kotlin" scheme="https://cohleke.github.io/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://cohleke.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android 指纹适配</title>
    <link href="https://cohleke.github.io/2018/03/12/Android-%E6%8C%87%E7%BA%B9%E7%9B%B8%E5%85%B3/"/>
    <id>https://cohleke.github.io/2018/03/12/Android-指纹相关/</id>
    <published>2018-03-12T02:53:01.000Z</published>
    <updated>2018-03-13T03:02:04.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1><img src="/2018/03/12/Android-指纹相关/01.png" title="demo"><h2 id="指纹识别适配"><a href="#指纹识别适配" class="headerlink" title="指纹识别适配"></a>指纹识别适配</h2><p>指纹识别适配会有很多问题，这些问题可以从下面三种情况中看出:</p><ul><li>Google官方支持指纹识别的标准接口是在Android6.0开始的，如果各个厂商都升级到6.0并且硬件上都给予支持，那么我们按照标准的指纹识别接口使用就可以了。</li><li>如果在android6.0发布以后，手机厂商来不及升级，但是工程师们参考了官方指纹识别的代码，把代码移植到他们的6.0版本以下的系统，或者参照Google提供的接口自己实现了一套指纹识别机制，只是对开发者暴露的接口一样，这样就可以像使用标准接口一样使用，但是这种情况就难说了，实现不好的可能本身就有很多bug，适配起也比较麻烦，不过起码还是能用的。</li><li>如果厂商在Google之前就已经做了指纹识别，那这种情况肯定不能使用官方标准接口，如果要适配这种设备，只能使用厂商提供的第三方指纹识别SDK。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;&lt;img src=&quot;/2018/03/12/Android-指纹相关/01.png&quot; title=&quot;demo&quot;&gt;
&lt;h2 id=&quot;指纹识别
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="Fingerprint" scheme="https://cohleke.github.io/tags/Fingerprint/"/>
    
      <category term="指纹" scheme="https://cohleke.github.io/tags/%E6%8C%87%E7%BA%B9/"/>
    
  </entry>
  
  <entry>
    <title>Webview填坑（hybrid / X5内核 等）</title>
    <link href="https://cohleke.github.io/2018/03/02/WebChromeClient/"/>
    <id>https://cohleke.github.io/2018/03/02/WebChromeClient/</id>
    <published>2018-03-02T02:34:18.000Z</published>
    <updated>2018-05-08T02:56:13.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webview填坑"><a href="#webview填坑" class="headerlink" title="webview填坑"></a>webview填坑</h1><h2 id="地理位置原生处理"><a href="#地理位置原生处理" class="headerlink" title="地理位置原生处理"></a>地理位置原生处理</h2><h3 id="覆盖WebChromeClient里的onGeolocationPermissionsShowPrompt方法请求原生定位"><a href="#覆盖WebChromeClient里的onGeolocationPermissionsShowPrompt方法请求原生定位" class="headerlink" title="覆盖WebChromeClient里的onGeolocationPermissionsShowPrompt方法请求原生定位"></a>覆盖WebChromeClient里的onGeolocationPermissionsShowPrompt方法请求原生定位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGeolocationPermissionsShowPrompt</span><span class="params">(String origin,</span></span></span><br><span class="line"><span class="function"><span class="params">Callback callback)</span> </span>&#123;</span><br><span class="line">    callback.invoke(origin, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">super</span>.onGeolocationPermissionsShowPrompt(origin, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cookies相关"><a href="#cookies相关" class="headerlink" title="cookies相关"></a>cookies相关</h2><h3 id="添加cookies"><a href="#添加cookies" class="headerlink" title="添加cookies"></a>添加cookies</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CookieSyncManager.createInstance(context);</span><br><span class="line">CookieManager cookieManager = CookieManager.getInstance();</span><br><span class="line"><span class="comment">////以上为原生webview方法，以下为x5的方法</span></span><br><span class="line">com.tencent.smtt.sdk.CookieSyncManager.createInstance(context);</span><br><span class="line">com.tencent.smtt.sdk.CookieManager cookieManager = com.tencent.smtt.sdk.CookieManager.getInstance();</span><br></pre></td></tr></table></figure><h3 id="清除cookies"><a href="#清除cookies" class="headerlink" title="清除cookies"></a>清除cookies</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CookieManager.getInstance().removeAllCookie();</span><br><span class="line"><span class="comment">////以上为原生webview方法，以下为x5的方法</span></span><br><span class="line">com.tencent.smtt.sdk.CookieManager.getInstance().removeAllCookie();</span><br></pre></td></tr></table></figure><h2 id="WebView与-JS-双向交互总结"><a href="#WebView与-JS-双向交互总结" class="headerlink" title="WebView与 JS 双向交互总结"></a>WebView与 JS 双向交互总结</h2><h3 id="对于Android调用JS代码的方法有2种："><a href="#对于Android调用JS代码的方法有2种：" class="headerlink" title="对于Android调用JS代码的方法有2种："></a>对于Android调用JS代码的方法有2种：</h3><h4 id="通过WebView的loadUrl"><a href="#通过WebView的loadUrl" class="headerlink" title="通过WebView的loadUrl()"></a>通过WebView的loadUrl()</h4><h4 id="通过WebView的evaluateJavascript"><a href="#通过WebView的evaluateJavascript" class="headerlink" title="通过WebView的evaluateJavascript()"></a>通过WebView的evaluateJavascript()</h4><h3 id="对于JS调用Android代码的方法有3种："><a href="#对于JS调用Android代码的方法有3种：" class="headerlink" title="对于JS调用Android代码的方法有3种："></a>对于JS调用Android代码的方法有3种：</h3><h4 id="通过WebView的addJavascriptInterface-进行对象映射"><a href="#通过WebView的addJavascriptInterface-进行对象映射" class="headerlink" title="通过WebView的addJavascriptInterface()进行对象映射"></a>通过WebView的addJavascriptInterface()进行对象映射</h4><h4 id="通过-WebViewClient-的shouldOverrideUrlLoading-方法回调拦截-url"><a href="#通过-WebViewClient-的shouldOverrideUrlLoading-方法回调拦截-url" class="headerlink" title="通过 WebViewClient 的shouldOverrideUrlLoading()方法回调拦截 url"></a>通过 WebViewClient 的shouldOverrideUrlLoading()方法回调拦截 url</h4><h4 id="通过-WebChromeClient-的onJsAlert-、onJsConfirm-、onJsPrompt-方法回调拦截JS对话框alert-、confirm-、prompt-消息"><a href="#通过-WebChromeClient-的onJsAlert-、onJsConfirm-、onJsPrompt-方法回调拦截JS对话框alert-、confirm-、prompt-消息" class="headerlink" title="通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt()方法回调拦截JS对话框alert()、confirm()、prompt()消息"></a>通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt()方法回调拦截JS对话框alert()、confirm()、prompt()消息</h4><img src="/2018/03/02/WebChromeClient/js.png" title="WebView与 JS 双向交互总结"><h2 id="不使用JS，实现原生拍照及图库"><a href="#不使用JS，实现原生拍照及图库" class="headerlink" title="不使用JS，实现原生拍照及图库"></a>不使用JS，实现原生拍照及图库</h2><img src="/2018/03/02/WebChromeClient/01.gif" title="demo"><h3 id="覆盖WebChromeClient里的方法"><a href="#覆盖WebChromeClient里的方法" class="headerlink" title="覆盖WebChromeClient里的方法"></a>覆盖WebChromeClient里的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onShowFileChooser</span><span class="params">(WebView webView,</span></span></span><br><span class="line"><span class="function"><span class="params">ValueCallback&lt;Uri[]&gt; filePathCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">FileChooserParams fileChooserParams)</span> </span>&#123;</span><br><span class="line">mUploadCallbackAboveL = filePathCallback;</span><br><span class="line">take();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; uploadMsg)</span> </span>&#123;</span><br><span class="line">mUploadMessage = uploadMsg;</span><br><span class="line">take();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; uploadMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">String acceptType)</span> </span>&#123;</span><br><span class="line">mUploadMessage = uploadMsg;</span><br><span class="line">take();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; uploadMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">String acceptType, String capture)</span> </span>&#123;</span><br><span class="line">mUploadMessage = uploadMsg;</span><br><span class="line">take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">File imageStorageDir = <span class="keyword">new</span> File(</span><br><span class="line">Environment</span><br><span class="line">.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),</span><br><span class="line"><span class="string">"MyApp"</span>);</span><br><span class="line"><span class="keyword">if</span> (!imageStorageDir.exists()) &#123;</span><br><span class="line">imageStorageDir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">File file = <span class="keyword">new</span> File(imageStorageDir + File.separator + <span class="string">"IMG_"</span></span><br><span class="line">+ String.valueOf(System.currentTimeMillis()) + <span class="string">".jpg"</span>);</span><br><span class="line">imageUri = Uri.fromFile(file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;Intent&gt; cameraIntents = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</span><br><span class="line"><span class="keyword">final</span> Intent captureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line"><span class="keyword">final</span> PackageManager packageManager = getPackageManager();</span><br><span class="line"><span class="keyword">final</span> List&lt;ResolveInfo&gt; listCam = packageManager.queryIntentActivities(</span><br><span class="line">captureIntent, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (ResolveInfo res : listCam) &#123;</span><br><span class="line"><span class="keyword">final</span> String packageName = res.activityInfo.packageName;</span><br><span class="line"><span class="keyword">final</span> Intent i = <span class="keyword">new</span> Intent(captureIntent);</span><br><span class="line">i.setComponent(<span class="keyword">new</span> ComponentName(res.activityInfo.packageName,</span><br><span class="line">res.activityInfo.name));</span><br><span class="line">i.setPackage(packageName);</span><br><span class="line">i.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);</span><br><span class="line">cameraIntents.add(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</span><br><span class="line">i.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">i.setType(<span class="string">"image/*"</span>);</span><br><span class="line">Intent chooserIntent = Intent.createChooser(i, <span class="string">"Image Chooser"</span>);</span><br><span class="line">chooserIntent.putExtra(Intent.EXTRA_INITIAL_INTENTS,</span><br><span class="line">cameraIntents.toArray(<span class="keyword">new</span> Parcelable[] &#123;&#125;));</span><br><span class="line">X5WebViewActivity.<span class="keyword">this</span>.startActivityForResult(chooserIntent,</span><br><span class="line">FILECHOOSER_RESULTCODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="覆盖onActivityResult及定义onActivityResultAboveL"><a href="#覆盖onActivityResult及定义onActivityResultAboveL" class="headerlink" title="覆盖onActivityResult及定义onActivityResultAboveL"></a>覆盖onActivityResult及定义onActivityResultAboveL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line"><span class="keyword">if</span> (requestCode == FILECHOOSER_RESULTCODE) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == mUploadMessage &amp;&amp; <span class="keyword">null</span> == mUploadCallbackAboveL)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Uri result = data == <span class="keyword">null</span> || resultCode != RESULT_OK ? <span class="keyword">null</span> : data</span><br><span class="line">.getData();</span><br><span class="line"><span class="keyword">if</span> (mUploadCallbackAboveL != <span class="keyword">null</span>) &#123;</span><br><span class="line">onActivityResultAboveL(requestCode, resultCode, data);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mUploadMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">String path = getPath(getApplicationContext(), result);</span><br><span class="line">Uri uri = Uri.fromFile(<span class="keyword">new</span> File(path));</span><br><span class="line">mUploadMessage.onReceiveValue(uri);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mUploadMessage.onReceiveValue(imageUri);</span><br><span class="line">&#125;</span><br><span class="line">mUploadMessage = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint</span>(<span class="string">"NewApi"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onActivityResultAboveL</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">Intent data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (requestCode != FILECHOOSER_RESULTCODE</span><br><span class="line">|| mUploadCallbackAboveL == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Uri[] results = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">results = <span class="keyword">new</span> Uri[] &#123; imageUri &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">String dataString = data.getDataString();</span><br><span class="line">ClipData clipData = data.getClipData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clipData != <span class="keyword">null</span>) &#123;</span><br><span class="line">results = <span class="keyword">new</span> Uri[clipData.getItemCount()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clipData.getItemCount(); i++) &#123;</span><br><span class="line">ClipData.Item item = clipData.getItemAt(i);</span><br><span class="line">results[i] = item.getUri();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dataString != <span class="keyword">null</span>)</span><br><span class="line">results = <span class="keyword">new</span> Uri[] &#123; Uri.parse(dataString) &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (results != <span class="keyword">null</span>) &#123;</span><br><span class="line">mUploadCallbackAboveL.onReceiveValue(results);</span><br><span class="line">mUploadCallbackAboveL = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">results = <span class="keyword">new</span> Uri[] &#123; imageUri &#125;;</span><br><span class="line">mUploadCallbackAboveL.onReceiveValue(results);</span><br><span class="line">mUploadCallbackAboveL = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebView开启硬件加速"><a href="#WebView开启硬件加速" class="headerlink" title="WebView开启硬件加速"></a>WebView开启硬件加速</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Application级别：</span><br><span class="line">&lt;applicationandroid:hardwareAccelerated=<span class="string">"true"</span> ...&gt;</span><br><span class="line"> </span><br><span class="line">Activity级别：</span><br><span class="line">&lt;activity android:hardwareAccelerated=<span class="string">"false"</span> ...&gt;</span><br><span class="line"> </span><br><span class="line">Window级别：</span><br><span class="line">getWindow().setFlags(</span><br><span class="line">    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</span><br><span class="line">    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</span><br><span class="line">      </span><br><span class="line">View级别：</span><br><span class="line"> mView.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="WebViewClient中的常用方法有"><a href="#WebViewClient中的常用方法有" class="headerlink" title="WebViewClient中的常用方法有"></a>WebViewClient中的常用方法有</h2><ul><li>onPageFinished(WebView view, String url)</li><li>onPageStarted(WebView view, String url, Bitmap favicon)</li><li>onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)</li><li>shouldInterceptRequest(WebView view, String url)</li><li>shouldOverrideUrlLoading(WebView view, String url)</li></ul><p>等,以上方法都是webview中请求过程等事件的处理方法.</p><h2 id="WebChromeClient中的常用方法有"><a href="#WebChromeClient中的常用方法有" class="headerlink" title="WebChromeClient中的常用方法有"></a>WebChromeClient中的常用方法有</h2><ul><li>onCloseWindow(WebView window)</li><li>onConsoleMessage(ConsoleMessage consoleMessage)</li><li>onJsAlert(WebView view, String url, String message, JsResult result)</li><li>onJsConfirm(WebView view, String url, String message, JsResult result)</li><li>onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result)</li><li>onPermissionRequest(PermissionRequest request)</li><li>onReceivedIcon(WebView view, Bitmap icon)</li><li>onReceivedTitle(WebView view, String title)</li><li>onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)</li></ul><p>等,以上方法都是webview和用户之间有交互的一些方法,如JS弹窗,文件选择弹窗,窗口关闭等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webview填坑&quot;&gt;&lt;a href=&quot;#webview填坑&quot; class=&quot;headerlink&quot; title=&quot;webview填坑&quot;&gt;&lt;/a&gt;webview填坑&lt;/h1&gt;&lt;h2 id=&quot;地理位置原生处理&quot;&gt;&lt;a href=&quot;#地理位置原生处理&quot; class=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="webview" scheme="https://cohleke.github.io/tags/webview/"/>
    
  </entry>
  
  <entry>
    <title>Android Activity启动过程</title>
    <link href="https://cohleke.github.io/2018/02/01/Android%20Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://cohleke.github.io/2018/02/01/Android Activity启动过程/</id>
    <published>2018-02-01T08:59:21.000Z</published>
    <updated>2018-03-11T09:11:38.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Activity启动过程"><a href="#Android-Activity启动过程" class="headerlink" title="Android - Activity启动过程"></a>Android - Activity启动过程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从点击桌面应用图标到应用显示的过程我们再熟悉不过了，下面我们来分析下这个过程都做了什么。</p><p>本文主要对以下问题分析：</p><ul><li>ActivityThread 是什么，它是一个线程吗，如何被启动的？</li><li>ActivityClientRecord 与 ActivityRecord 是什么？</li><li>Context 是什么，ContextImpl，ContextWapper 是什么？</li><li>Instrumentation 是什么？</li><li>Application 是什么，什么时候创建的，每个应用程序有几个 Application？</li><li>点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？</li><li>Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？</li></ul><h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h2><img src="/2018/02/01/Android%20Activity启动过程/01.png" title="系统启动过程"><p>我们知道 Android 系统启动后已经启动了 Zygote，ServiceManager，SystemServer 等系统进程；ServiceManager 进程中完成了 Binder 初始化；SystemServer 进程中 ActivityManagerService，WindowManagerService，PackageManagerService 等系统服务在 ServiceManager 中已经注册；最后启动了 Launcher 桌面应用。</p><p>其实 Launcher 本身就是一个应用程序，运行在自己的进程中，我们看到的桌面就是 Launcher 中的一个 Activity。</p><p>应用安装的时候，通过 PackageManagerService 解析 apk 的 AndroidManifest.xml 文件，提取出这个 apk 的信息写入到 packages.xml 文件中，这些信息包括：权限、应用包名、icon、apk 的安装位置、版本、userID 等等。packages.xml 文件位于系统目录下/data/system/packages.xml。</p><p>同时桌面 Launcher 会为安装过的应用生成不同的应用入口，对应桌面上的应用图标，下面分析点击应用图标的到应用启动的过程。</p><h2 id="点击-Launcher-中应用图标"><a href="#点击-Launcher-中应用图标" class="headerlink" title="点击 Launcher 中应用图标"></a>点击 Launcher 中应用图标</h2><img src="/2018/02/01/Android%20Activity启动过程/02.png" title="点击 Launcher 执行过程"><p>点击 Launcher 中应用图标将会执行以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Launcher.startActivitySafely()</span><br><span class="line">Launcher.startActivity()</span><br><span class="line"><span class="comment">//以上两个方法主要是检查将要打开的 Activity 是否存在</span></span><br><span class="line"></span><br><span class="line">Activity.startActivity()</span><br><span class="line"><span class="comment">//这段代码大家已经很熟悉，经常打开 Activity 用的就是这个方法</span></span><br><span class="line"></span><br><span class="line">Activity.startActivityForResult()</span><br><span class="line"><span class="comment">//默认 requestCode = -1，也可通过调用 startActivityForResult() 传入 requestCode。 </span></span><br><span class="line"><span class="comment">//然后通过 MainThread 获取到 ApplicationThread 传入下面方法。</span></span><br><span class="line"></span><br><span class="line">Instrumentation.execStartActivity()</span><br><span class="line"><span class="comment">//通过 ActivityManagerNative.getDefault() 获取到 ActivityManagerService 的代理为进程通讯作准备。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerNative.getDefault().startActivity()</span><br><span class="line">ActivityManagerProxy.startActivity()</span><br><span class="line"><span class="comment">//调用代理对象的 startActivity() 方法，发送 START_ACTIVITY_TRANSACTION 命令。</span></span><br></pre></td></tr></table></figure><p>在 system_server 进程中的服务端 ActivityManagerService 收到 START_ACTIVITY_TRANSACTION 命令后进行处理，调用 startActivity() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.startActivity() -&gt; startActivityAsUser(intent, requestCode, userId)</span><br><span class="line"><span class="comment">//通过 UserHandle.getCallingUserId() 获取到 userId 并调用 startActivityAsUser() 方法。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityMayWait() -&gt; resolveActivity()</span><br><span class="line"><span class="comment">//通过 intent 创建新的 intent 对象，即使之前 intent 被修改也不受影响。 然后调用 resolveActivity()。</span></span><br><span class="line"><span class="comment">//然后通过层层调用获取到 ApplicationPackageManager 对象。</span></span><br><span class="line"></span><br><span class="line">PackageManagerService.resolveIntent() -&gt; queryIntentActivities()</span><br><span class="line"><span class="comment">//获取 intent 所指向的 Activity 信息，并保存到 Intent 对象。</span></span><br><span class="line"></span><br><span class="line">PackageManagerService.chooseBestActivity()</span><br><span class="line"><span class="comment">//当存在多个满足条件的 Activity 则会弹框让用户来选择。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityLocked()</span><br><span class="line"><span class="comment">//获取到调用者的进程信息。 通过 Intent.FLAG_ACTIVITY_FORWARD_RESULT 判断是否需要进行 startActivityForResult 处理。 </span></span><br><span class="line"><span class="comment">//检查调用者是否有权限来调用指定的 Activity。 </span></span><br><span class="line"><span class="comment">//创建 ActivityRecord 对象，并检查是否运行 App 切换。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityUncheckedLocked() -&gt; startActivityLocked()</span><br><span class="line"><span class="comment">//进行对 launchMode 的处理[可参考 Activity 启动模式]，创建 Task 等操作。</span></span><br><span class="line"><span class="comment">//启动 Activity 所在进程，已存在则直接 onResume()，不存在则创建 Activity 并处理是否触发 onNewIntent()。</span></span><br><span class="line"></span><br><span class="line">ActivityStack.resumeTopActivityInnerLocked()</span><br><span class="line"><span class="comment">//找到 resume 状态的 Activity，执行 startPausingLocked() 暂停该 Activity，同时暂停所有处于后台栈的 Activity，找不到 resume 状态的 Activity 则回桌面。</span></span><br><span class="line"><span class="comment">//如果需要启动的 Activity 进程已存在，直接设置 Activity 状态为 resumed。 调用下面方法。</span></span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startSpecificActivityLocked()</span><br><span class="line"><span class="comment">//进程存在调用 realStartActivityLocked() 启动 Activity，进程不存在则调用下面方法。</span></span><br></pre></td></tr></table></figure><h2 id="fork-新进程"><a href="#fork-新进程" class="headerlink" title="fork 新进程"></a>fork 新进程</h2><p>从 Launcher 点击图标，如果应用没有启动过，则会 fork 一个新进程。创建新进程的时候，ActivityManagerService 会保存一个 ProcessRecord 信息，Activity 应用程序中的AndroidManifest.xml 配置文件中，我们没有指定 Application 标签的 process 属性，系统就会默认使用 package 的名称。每一个应用程序都有自己的 uid，因此，这里 uid + process 的组合就可以为每一个应用程序创建一个 ProcessRecord。每次在新建新进程前的时候会先判断这个 ProcessRecord 是否已存在，如果已经存在就不会新建进程了，这就属于应用内打开 Activity 的过程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.startProcessLocked()</span><br><span class="line"><span class="comment">//进程不存在请求 Zygote 创建新进程。 创建成功后切换到新进程。</span></span><br></pre></td></tr></table></figure><p>进程创建成功切换至 App 进程，进入 app 进程后将 ActivityThread 类加载到新进程，并调用 ActivityThread.main() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.main()</span><br><span class="line"><span class="comment">//创建主线程的 Looper 对象，创建 ActivityThread 对象，ActivityThread.attach() 建立 Binder 通道，开启 Looper.loop() 消息循环。</span></span><br><span class="line"></span><br><span class="line">ActivityThread.attach()</span><br><span class="line"><span class="comment">//开启虚拟机各项功能，创建 ActivityManagerProxy 对象，调用基于 IActivityManager 接口的 Binder 通道 ActivityManagerProxy.attachApplication()。</span></span><br><span class="line"></span><br><span class="line">ActivityManagerProxy.attachApplication()</span><br><span class="line"><span class="comment">//发送 ATTACH_APPLICATION_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><p>此时只创建了应用程序的 ActivityThread 和 ApplicationThread，和开启了 Handler 消息循环机制，其他的都还未创建， ActivityThread.attach(false) 又会最终到 ActivityMangerService 的 attachApplication，这个工程其实是将本地的 ApplicationThread 传递到 ActivityMangerService。然后 ActivityMangerService 就可以通过 ApplicationThread 的代理 ApplicationThreadProxy 来调用应用程序 ApplicationThread.bindApplication，通知应用程序的 ApplicationThread 已和 ActivityMangerService 绑定，可以不借助其他进程帮助直接通信了。此时 Launcher 的任务也算是完成了。</p><p>在 system_server 进程中的服务端 ActivityManagerService 收到 ATTACH_APPLICATION_TRANSACTION 命令后进行处理，调用 attachApplication()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityMangerService.attachApplication() -&gt; attachApplicationLocked()</span><br><span class="line"><span class="comment">//首先会获取到进程信息 ProcessRecord。 绑定死亡通知，移除进程启动超时消息。 获取到应用 ApplicationInfo 并绑定应用 IApplicationThread.bindApplication(appInfo)。</span></span><br><span class="line"><span class="comment">//然后检查 App 所需组件。</span></span><br></pre></td></tr></table></figure><ul><li>Activity: 检查最顶层可见的 Activity 是否等待在该进程中运行，调用 ActivityStackSupervisor.attachApplicationLocked()。</li><li>Service：寻找所有需要在该进程中运行的服务，调用 ActiveServices.attachApplicationLocked()。</li><li>Broadcast：检查是否在这个进程中有下一个广播接收者，调用 sendPendingBroadcastsLocked()。</li></ul><p>此处讨论 Activity 的启动过程，只讨论 ActivityStackSupervisor.attachApplicationLocked() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityStackSupervisor.attachApplicationLocked() -&gt; realStartActivityLocked()</span><br><span class="line"><span class="comment">//将该进程设置为前台进程 PROCESS_STATE_TOP，调用 ApplicationThreadProxy.scheduleLaunchActivity()。</span></span><br><span class="line"></span><br><span class="line">ApplicationThreadProxy.scheduleLaunchActivity()</span><br><span class="line"><span class="comment">//发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><p>发送送完 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，还会发送 BIND_APPLICATION_TRANSACTION 命令来创建 Application。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationThreadProxy.bindApplication()</span><br><span class="line"><span class="comment">//发送 BIND_APPLICATION_TRANSACTION 命令</span></span><br></pre></td></tr></table></figure><h2 id="App-进程初始化"><a href="#App-进程初始化" class="headerlink" title="App 进程初始化"></a>App 进程初始化</h2><p>在 app 进程中，收到 BIND_APPLICATION_TRANSACTION 命令后调用 ActivityThread.bindApplication()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.bindApplication()</span><br><span class="line"><span class="comment">//缓存 Service，初始化 AppBindData，发送消息 H.BIND_APPLICATION。</span></span><br></pre></td></tr></table></figure><p>ApplicationThreadProxy.bindApplication(…) 会传来这个应用的一些信息，如ApplicationInfo，Configuration 等，在 ApplicationThread.bindApplication 里会待信息封装成A ppBindData，通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(H.BIND_APPLICATION, data)</span><br></pre></td></tr></table></figure><p>将信息放到应用里的消息队列里，通过 Handler 消息机制，在 ActivityThread.handleMeaasge 里处理 H.BIND_APPLICATION 的信息，调用 AplicationThread.handleBindApplication。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    Process.setArgV0(data.processName);<span class="comment">//设置进程名</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化 mInstrumentation</span></span><br><span class="line">    <span class="keyword">if</span>(data.mInstrumentation!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Application，data.info 是个 LoadedApk 对象。</span></span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">    mInitialApplication = app;</span><br><span class="line">    <span class="comment">//调用 Application 的 onCreate()方法。</span></span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;   </span><br><span class="line">       <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时新建一个 Application 的 ContextImpl 对象，</span></span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过在 handleBindApplication 创建的 mInstrumentation 对象新建一个 Application 对象，同时进行 attach。</span></span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);</span><br><span class="line">    appContext.setOuterContext(app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置进程名，获取 LoadedApk 对象，创建 ContextImpl 上下文</span></span><br><span class="line"><span class="comment">//LoadedApk.makeApplication() 创建 Application 对象，调用 Application.onCreate() 方法。</span></span><br></pre></td></tr></table></figure><p>Instrumentation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br><span class="line">Instrumentation类：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span>  </span>&#123;</span><br><span class="line">    <span class="comment">//实例化 Application</span></span><br><span class="line">    Application app = (Application)clazz.newInstance();     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Application 和 context绑定</span></span><br><span class="line">    app.attach(context);    </span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//attach 就是将新建的 ContextImpl 赋值到 mBase，这个 ContextImpl 对象就是所有Application 内 Context 的具体实现，同时赋值一些其他的信息如 mLoadedApk。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;    </span><br><span class="line">    mBase = base;  </span><br><span class="line">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时 Application 就创建好了，这点很重要，很多资料里说 Application 是在performLaunchActivity() 里创建的，因为 performLaunchActivity() 也有mInstrumentation.newApplication 这个调用，newApplication() 函数中可看出会先判断是否以及创建了 Application，如果之前已经创建，就返回已创建的 Application 对象。</p><h2 id="Activity-启动"><a href="#Activity-启动" class="headerlink" title="Activity 启动"></a>Activity 启动</h2><p>上面 fork 进程时会发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，在 app 进程中，收到 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令后调用 ApplicationThread.scheduleLaunchActivity()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ApplicationThread.scheduleLaunchActivity()</span><br><span class="line"><span class="comment">//发送消息 H.LAUNCH_ACTIVITY。</span></span><br><span class="line"></span><br><span class="line">sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line"></span><br><span class="line">ActivityThread.handleLaunchActivity()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onConfigurationChanged()，初始化 WindowManagerService。</span></span><br><span class="line"><span class="comment">//调用 ActivityThread.performLaunchActivity()</span></span><br><span class="line"></span><br><span class="line">ActivityThread.performLaunchActivity() &#123;</span><br><span class="line">    <span class="comment">//类似 Application 的创建过程，通过 classLoader 加载到 activity.</span></span><br><span class="line">    activity = mInstrumentation.newActivity(classLoader, </span><br><span class="line">               component.getClassName(), r.intent);</span><br><span class="line">    <span class="comment">//因为 Activity 有界面，所以其 Context 是 ContextThemeWrapper 类型，但实现类仍是ContextImpl.</span></span><br><span class="line">    Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">    activity.attach(context,mInstrumentation,application,...);</span><br><span class="line">    <span class="comment">//与 Window 进行关联</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//attach 后调用 activity 的 onCreate()方法。</span></span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity,...)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在ActivityThread.handleLaunchActivity里，接着调用</span></span><br><span class="line"></span><br><span class="line">Activity.performCreate() -&gt; onCreate()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onCreate()。</span></span><br><span class="line"></span><br><span class="line">Activity.setContentView()</span><br><span class="line"><span class="comment">//设置 layout 布局</span></span><br><span class="line"></span><br><span class="line">ActivityThread.performResumeActivity()</span><br><span class="line"><span class="comment">//最终回调目标 Activity 的 onResume()。</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Activity 的整体启动流程如图所示：</p><img src="/2018/02/01/Android%20Activity启动过程/03.jpg" title="Activity 的整体启动流程"><ul><li>ActivityThread 是什么，它是一个线程吗，如何被启动的？</li></ul><p>它不是一个线程，它是运行在 App 进程中的主线程中的一个方法中。当 App 进程创建时会执行 ActivityThread.main()，ActivityThread.main() 首先会创建 Looper 执行 Looper.prepareMainLooper()；然后创建 ActivityThread 并调用 ActivityThread.attach() 方法告诉 ActivityManagerService 我们创建了一个应用 并将 ApplicationThread 传给 ActivityManagerService；最后调用 Looper.loop()。</p><ul><li>ActivityClientRecord 与 ActivityRecord 是什么？</li></ul><p>记录 Activity 相关信息，比如：Window，configuration，ActivityInfo 等。<br>ActivityClientRecord 是客户端的，ActivityRecord 是 ActivityManagerService 服务端的。</p><ul><li>Context 是什么，ContextImpl，ContextWapper 是什么？</li></ul><p>Context 定义了 App 进程的相关环境，Context 是一个接口，ContextImpl 是子类，ContextWapper 是具体实现。</p><p>应用资源是在 Application 初始化的时候，也就是创建 Application，ContextImpl 的时候，ContextImpl 就包含这个路径，主要就是对就是 ResourcesManager 这个单例的引用。</p><p>可以看出每次创建 Application 和 Acitvity 以及 Service 时就会有一个 ContextImpl 实例，ContentProvider 和B roadcastReceiver 的 Context 是其他地方传入的。</p><p>所以 Context 数量 = Application 数量 + Activity 数量 + Service 数量，单进程情况下 Application 数量就是 1。</p><ul><li>Instrumentation 是什么？</li></ul><p>管理着组件 Application，Activity，Service 等的创建，生命周期调用。</p><ul><li>Application 是什么，什么时候创建的，每个应用程序有几个 Application？</li></ul><p>Application 是在 ActivityThread.handleBindApplication() 中创建的，一个进程只会创建一个 Application，但是一个应用如果有多个进程就会创建多个 Application 对象。</p><ul><li>点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？</li></ul><p>点击 Launcher 时会创建一个新进程来开启 Activity，而应用内打开 Activity，如果 Activity 不指定新进程，将在原来进程打开，是否开启新进程实在 ActivityManagerService 进行控制的，上面分析得到，每次开启新进程时会保存进程信息，默认为 应用包名 + 应用UID，打开 Activity 时会检查请求方的信息来判断是否需要新开进程。Launcher 打开 Activity 默认 ACTIVITY_NEW_TASK，新开一个 Activity 栈来保存 Activity 的信息。</p><ul><li>Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？</li></ul><p>Activity.onCreate() 完成了 App 进程，Application，Activity 的创建，调用 setContentView() 给 Activity 设置了 layout 布局。</p><p>Activity.onResume() 完成了 Activity 中 Window 与 WindowManager 的关联，并对所有子 View 进行渲染并显示。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/6685853/" target="_blank" rel="noopener">Android应用程序的Activity启动过程简要介绍和学习计划</a></li><li><a href="https://silencedut.github.io/2016/08/02/Android%20应用点击图标到Activity界面显示的过程分析/" target="_blank" rel="noopener">Android 应用点击图标到Activity界面显示的过程分析</a></li><li>《深入理解 Android 内核设计思想》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Activity启动过程&quot;&gt;&lt;a href=&quot;#Android-Activity启动过程&quot; class=&quot;headerlink&quot; title=&quot;Android - Activity启动过程&quot;&gt;&lt;/a&gt;Android - Activity启动过程&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Activity" scheme="https://cohleke.github.io/tags/Activity/"/>
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android常见内存泄露分析</title>
    <link href="https://cohleke.github.io/2018/01/21/Android%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%88%86%E6%9E%90/"/>
    <id>https://cohleke.github.io/2018/01/21/Android常见内存泄露分析/</id>
    <published>2018-01-21T15:15:41.000Z</published>
    <updated>2018-03-09T15:31:37.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何找到项目中存在的内存泄露的地方？"><a href="#如何找到项目中存在的内存泄露的地方？" class="headerlink" title="如何找到项目中存在的内存泄露的地方？"></a>如何找到项目中存在的内存泄露的地方？</h1><h2 id="确定是否存在内存泄露"><a href="#确定是否存在内存泄露" class="headerlink" title="确定是否存在内存泄露"></a>确定是否存在内存泄露</h2><h3 id="Android-Monitors的内存分析"><a href="#Android-Monitors的内存分析" class="headerlink" title="Android Monitors的内存分析"></a>Android Monitors的内存分析</h3><p>最直观的看内存增长情况，知道该动作是否发生内存泄露。<br>动作发生之前：GC完后内存1.4M; 动作发生之后：GC完后内存1.6M</p><h3 id="使用MAT内存分析工具"><a href="#使用MAT内存分析工具" class="headerlink" title="使用MAT内存分析工具"></a>使用MAT内存分析工具</h3><p>MAT分析heap的总内存占用大小来初步判断是否存在泄露<br>Heap视图中有一个Type叫做data object，即数据对象，也就是我们的程序中大量存在的类类型的对象。<br>在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，<br>一般情况下，这个值的大小决定了是否会有内存泄漏。<br>我们反复执行某一个操作并同时执行GC排除可以回收掉的内存，注意观察data object的Total Size值，<br>正常情况下Total Size值都会稳定在一个有限的范围内，也就是说由于程序中的的代码良好，没有造成对象不被垃圾回收的情况。<br>反之如果代码中存在没有释放对象引用的情况，随着操作次数的增多Total Size的值会越来越大。<br>那么这里就已经初步判断这个操作导致了内存泄露的情况。</p><h2 id="先找怀疑对象-哪些对象属于泄露的"><a href="#先找怀疑对象-哪些对象属于泄露的" class="headerlink" title="先找怀疑对象(哪些对象属于泄露的)"></a>先找怀疑对象(哪些对象属于泄露的)</h2><p>MAT对比操作前后的hprof来定位内存泄露是泄露了什么数据对象。（这样做可以排除一些对象，不用后面去查看所有被引用的对象是否是嫌疑）<br>快速定位到操作前后所持有的对象哪些是增加了(GC后还是比之前多出来的对象就可能是泄露对象嫌疑犯)<br>技巧：Histogram中还可以对对象进行Group，比如选择Group By Package更方便查看自己Package中的对象信息。</p><h2 id="MAT分析hprof来定位内存泄露的原因所在。-哪个对象持有了上面怀疑出来的发生泄露的对象"><a href="#MAT分析hprof来定位内存泄露的原因所在。-哪个对象持有了上面怀疑出来的发生泄露的对象" class="headerlink" title="MAT分析hprof来定位内存泄露的原因所在。(哪个对象持有了上面怀疑出来的发生泄露的对象)"></a>MAT分析hprof来定位内存泄露的原因所在。(哪个对象持有了上面怀疑出来的发生泄露的对象)</h2><ul><li>Dump出内存泄露“当时”的内存镜像hprof，分析怀疑泄露的类；</li><li>把上面2得出的这些嫌疑犯一个一个排查个遍。步骤：</li><li>进入Histogram，过滤出某一个嫌疑对象类</li><li>然后分析持有此类对象引用的外部对象（在该类上面点击右键List Objects—&gt;with incoming references）</li><li>再过滤掉一些弱引用、软引用、虚引用，因为它们迟早可以被GC干掉不属于内存泄露<br>(在类上面点击右键Merge Shortest Paths to GC Roots—&gt;exclude all phantom/weak/soft etc.references)</li><li>逐个分析每个对象的GC路径是否正常<br>此时就要进入代码分析此时这个对象的引用持有是否合理，这就要考经验和体力了！<br>（比如上课的例子中：旋转屏幕后MainActivity有两个，肯定MainActivity发生泄露了，<br>那谁导致他泄露的呢？原来是我们的CommonUtils类持有了旋转之前的那个MainActivity他，<br>那是否合理？结合逻辑判断当然不合理，由此找到内存泄露根源是CommonUtils类持有了该MainActivity实例造成的。<br>怎么解决？罪魁祸首找到了，怎么解决应该不难了，不同情况解决办法不一样，要靠你的智慧了。）</li></ul><p>context.getapplictioncontext()可以吗？<br>可以！！只要让CommonUtils类不直接只有MainActivity的实例就可以了。</p><p>一般我是最笨的方法解决<br>new出来对象，用完后把它 = null;这样算不算优化<br>假如：方法里面定义的对象，要去管吗？一般不需要管。<br>    自己=null，要自己去控制所有对象的生命周期 判断各种空指针，有点麻烦。<br>    但是在很多时候去想到主动将对象置为null是很好的习惯。</p><p>判断一个应用里面内存泄露避免得很好，怎么看？<br>当app退出的时候，这个进程里面所有的对象应该就都被回收了，尤其是很容易被泄露的（View，Activity）是否还内存当中。<br>可以让app退出以后，查看系统该进程里面的所有的View、Activity对象是否为0.<br>工具：使用AndroidStudio–AndroidMonitor–System Information–Memory Usage查看Objects里面的views和Activity的数量是否为0.<br>命令行模式：</p><h1 id="内存泄露经常出现的例子"><a href="#内存泄露经常出现的例子" class="headerlink" title="内存泄露经常出现的例子"></a>内存泄露经常出现的例子</h1><p>内存泄露(Memory Leak)：<br>    进程中某些对象已经没有使用价值了，但是他们却还可以直接或者间接地被引用到GC Root导致无法回收。<br>    当内存泄露过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM.<br>内存溢出（OOM）：<br>    当应用占用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出。比如：加载大图片。</p><h2 id="静态变量引起的内存泄露"><a href="#静态变量引起的内存泄露" class="headerlink" title="静态变量引起的内存泄露"></a>静态变量引起的内存泄露</h2><p>当调用getInstance时，如果传入的context是Activity的context。只要这个单利没有被释放，那么这个<br>Activity也不会被释放一直到进程退出才会释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CommUtil instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CommUtil</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommUtil <span class="title">getInstance</span><span class="params">(Context mcontext)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">    instance = <span class="keyword">new</span> CommUtil(mcontext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//        else&#123;</span></span><br><span class="line"><span class="comment">//            instance.setContext(mcontext);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="非静态内部类引起内存泄露"><a href="#非静态内部类引起内存泄露" class="headerlink" title="非静态内部类引起内存泄露"></a>非静态内部类引起内存泄露</h2><p>(包括匿名内部类)<br>    错误的示范：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span></span>&#123;<span class="comment">//隐式持有MainActivity实例。MainActivity.this.a</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//int b=a;</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>解决方案：<br>将非静态内部类修改为静态内部类。<br>（静态内部类不会隐式持有外部类）</p><p>当使用软引用或者弱引用的时候，MainActivity难道很容易或者可以被GC回收吗？》<br>GC回收的机制是什么？当MainActivity不被任何的对象引用。<br>虽然Handler里面用的是软引用/弱引用，但是并不意味着不存在其他的对象引用该MainActivity。<br>我连MainActivity都被回收了，那他里面的Handler还玩个屁。</p><h2 id="不需要用的监听未移除会发生内存泄露"><a href="#不需要用的监听未移除会发生内存泄露" class="headerlink" title="不需要用的监听未移除会发生内存泄露"></a>不需要用的监听未移除会发生内存泄露</h2><p>例1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tv.setOnClickListener();<span class="comment">//监听执行完回收对象</span></span><br><span class="line"><span class="comment">//add监听，放到集合里面</span></span><br><span class="line">tv.getViewTreeObserver().addOnWindowFocusChangeListener(<span class="keyword">new</span> ViewTreeObserver.OnWindowFocusChangeListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//监听view的加载，view加载出来的时候，计算他的宽高等。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算完后，一定要移除这个监听</span></span><br><span class="line">        tv.getViewTreeObserver().removeOnWindowFocusChangeListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>例2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SensorManager sensorManager = getSystemService(SENSOR_SERVICE);</span><br><span class="line">   Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);</span><br><span class="line">   sensorManager.registerListener(<span class="keyword">this</span>,sensor,SensorManager.SENSOR_DELAY_FASTEST);</span><br><span class="line">   <span class="comment">//不需要用的时候记得移除监听</span></span><br><span class="line">   sensorManager.unregisterListener(listener);</span><br></pre></td></tr></table></figure></p><h2 id="资源未关闭引起的内存泄露情况"><a href="#资源未关闭引起的内存泄露情况" class="headerlink" title="资源未关闭引起的内存泄露情况"></a>资源未关闭引起的内存泄露情况</h2><p>比如：BroadCastReceiver、Cursor、Bitmap、IO流、自定义属性attribute<br>attr.recycle()回收。<br>当不需要使用的时候，要记得及时释放资源。否则就会内存泄露。</p><h2 id="无限循环动画"><a href="#无限循环动画" class="headerlink" title="无限循环动画"></a>无限循环动画</h2><p>没有在onDestroy中停止动画，否则Activity就会变成泄露对象。<br>比如：轮播图效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何找到项目中存在的内存泄露的地方？&quot;&gt;&lt;a href=&quot;#如何找到项目中存在的内存泄露的地方？&quot; class=&quot;headerlink&quot; title=&quot;如何找到项目中存在的内存泄露的地方？&quot;&gt;&lt;/a&gt;如何找到项目中存在的内存泄露的地方？&lt;/h1&gt;&lt;h2 id=&quot;确
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="内存泄露" scheme="https://cohleke.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="性能优化" scheme="https://cohleke.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android Handler消息机制</title>
    <link href="https://cohleke.github.io/2018/01/07/Android%20Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://cohleke.github.io/2018/01/07/Android Handler消息机制/</id>
    <published>2018-01-07T08:41:27.000Z</published>
    <updated>2018-03-11T08:58:17.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Handler消息机制"><a href="#Android-Handler消息机制" class="headerlink" title="Android-Handler消息机制"></a>Android-Handler消息机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android 的消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper 的工作过程。 Handler 的主要作用是将某个任务切换到 Handler 所在的线程中去执行。</p><h2 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h2><p>Handler工作流程</p><img src="/2018/01/07/Android%20Handler消息机制/01.jpg" title="Handler工作流程"><p>Looper</p><blockquote><p><strong>每个线程中最多只能有一个 Looper 对象</strong>，由 Looper 来管理此线程里的 MessageQueue (消息队列)。</p><p>可以通过 <strong>Looper.myLooper()</strong> 获取当前线程的 Looper 实例，通过 <strong>Looper.getMainLooper()</strong> 获取主（UI）线程的 Looper 实例。</p><p>Lopper 会以无限循环的形式去查找是否有新消息，如果有就处理消息，否则就一直等待着。</p></blockquote><p>Handler</p><blockquote><p>你可以构造 Handler 对象来与 Looper 沟通，通过 <strong>push</strong> 发送新消息到 MessageQueue 里；或者通过 <strong>handleMessage</strong> 接收 Looper 从 MessageQueue 取出来消息。</p></blockquote><p>MessageQueue</p><blockquote><p>MessageQueue是一个消息队列，内部存储了一组消息，以队列的形式对外提供插入和<br>删除的工作，内部采用单链表的数据结构来存储消息列表。</p></blockquote><p>ActivityThread</p><blockquote><p>我们经常提到的主线程，也叫UI线程，它就是 ActivityThread，主线程启动会<strong>默认初始化一个 Looper 并创建 Handler</strong>。</p><p><strong>一个线程中只有一个 Looper 实例，一个 MessageQueue 实例，可以有多个 Handler 实例。</strong></p></blockquote><p>ThreadLocal</p><blockquote><p>一个线程内部的数据存储类，通过它可以在指定线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获得数据。</p><p>对于 Handler 来说，它需要获取当前线程的 Looper ,而 Looper 的作用于就是线程并且不同的线程具有不同的 Looper ，通过 ThreadLocal 可以轻松实现线程中的存取。</p><p>ThreadLocal原理：不同线程访问同一个ThreadLoacl的get方法，ThreadLocal的get方法会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找对应的Value值。</p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>通过上面分析我们知道使用 Handler 之前必须先调用 <strong>Looper.prepare();</strong> 进行初始化，我们先看下 Looper 的源码。</p><h4 id="1-Looper-工作原理"><a href="#1-Looper-工作原理" class="headerlink" title="1. Looper 工作原理"></a>1. Looper 工作原理</h4><p>先看一下 Looper 工作流程</p><img src="/2018/01/07/Android%20Handler消息机制/03.png" title="Looper工作流程"><p>Looper 源码最上面的注释里有一个使用示例如下，可以清晰的看出 Looper 的使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Looper.prepare();<span class="comment">//先初始化 Looper</span></span><br><span class="line">         mHandler = <span class="keyword">new</span> Handler() &#123;<span class="comment">//创建 Handler</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">// process incoming messages here</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         Looper.loop();<span class="comment">//启用 Looper 的 loop 方法开启消息轮询</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接续看一下 Looper 的完整源码，分析下工作过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="comment">//每个线程都会有一个ThreadLocal 用来保存 Looper对象（里面包含了主线程和 MessageQueue）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// 主线程的 Looper</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;<span class="comment">//保存消息队列</span></span><br><span class="line">    <span class="keyword">final</span> Thread mThread;<span class="comment">//保存主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;<span class="comment">//为当前线程创建 Looper</span></span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//一个线程只能有一个 Looper， 否则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//将创建的 Looper 放入 ThreadLocal</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化主线程的 Looper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取主线程的 Looper</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> sMainLooper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在当前线程中开启轮询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//从 ThreadLocal 中取出当前线程的 Looper 对象</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//Looper 没有调用 Looper.prepare() 初始化，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//从 Looper 对象中取出消息队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// 不断的取出消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line"><span class="comment">//取出消息的 target (也就是 Handler)，执行分发消息的操作</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();<span class="comment">//消息已经分发，进行回收操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();<span class="comment">//从 ThreadLocal 中取出当前线程的 Looper 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建消息队列</span></span><br><span class="line">        mThread = Thread.currentThread();<span class="comment">//保存当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">false</span>);<span class="comment">//直接退出消息循环，不管是否还有消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">true</span>);<span class="comment">//执行完所有的消息，退出消息循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-MessageQueue-工作原理"><a href="#2-MessageQueue-工作原理" class="headerlink" title="2. MessageQueue 工作原理"></a>2. MessageQueue 工作原理</h4><p>在 Looper 中创建了 MessageQueue，我们接着看下 MessageQueue 是怎么工作的。</p><p>MessageQueue 工作流程</p><img src="/2018/01/07/Android%20Handler消息机制/02.png" title="MessageQueue工作流程"><p>MessageQueue的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line"><span class="comment">//构造函数，quitAllowed 用来标识是否允许退出。</span></span><br><span class="line"><span class="comment">//主线程是不允许退出的（不然会退出整个程序），子线程可以退出。</span></span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再看一下 MessageQueue.enqueueMessage() 的源码，分析下是怎么添加消息的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 如果消息队列里面没有消息，或者消息的执行时间比里面的消息早，就把这条消息设置成第一条消息。</span></span><br><span class="line"><span class="comment">//一般不会出现这种情况，因为系统一定会有很多消息。</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果消息队列里面有消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//找到消息队列里面的最后一条消息</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;<span class="comment">//把消息添加到最后</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了怎么添加消息，我们再看下 MessageQueue.next() 方法是怎么取出消息的，也就是 Looper.loop() 方法中不断取消息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;<span class="comment">//拿到当前的消息队列</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//处理异步的消息，暂不讨论</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//取出一条消息，消息队列往后移动一个</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();<span class="comment">//标记为已使用</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 MessageQueue 是个链表结构，里面保存的是 Message，我们再看下 Message 是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;<span class="comment">//消息类型，标识消息的作用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;<span class="comment">//整型参数1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;<span class="comment">//整型参数2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object obj;<span class="comment">//复杂对象参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Messenger replyTo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IN_USE = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//标记消息已使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** If set message is asynchronous */</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ASYNCHRONOUS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;<span class="comment">//标记消息是否异步</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Flags to clear in the copyFrom method */</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">int</span> flags;<span class="comment">//消息当前标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">long</span> when;<span class="comment">//消息执行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Bundle data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Handler target;<span class="comment">//Handler 用于执行 handleMessage();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*package*/</span> Runnable callback;<span class="comment">//消息是一个Runnable</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next;<span class="comment">//下一个消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//控制并发访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//消息池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//消息池数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//消息最大数量</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Handler-工作原理"><a href="#3-Handler-工作原理" class="headerlink" title="3. Handler 工作原理"></a>3. Handler 工作原理</h4><p>在 Message 中我们看到了 target 是一个 Handler，我们看下 Handler 是怎么与 Looper 和 MessageQueue 一起搭配工作的。</p><p>看一下 Handler 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;<span class="comment">//如果消息体是 Runnable 就执行 run()</span></span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果创建 Handler 时传入了 Callback，就执行 Callback 里面的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);<span class="comment">//如果上述两种都没有实现，就执行 handleMessage 的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;<span class="comment">//可以指定关联哪个线程的 Looper</span></span><br><span class="line">        <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程调用的构造方法，主线程已经调用了 Looper.prepareMainLooper();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();<span class="comment">//取出主线程的 Looper</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;<span class="comment">//把 Handler 的 mQueue 指向 Looper 中的 mQueue</span></span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种构造方法，专门给子线程中创建 Handler 时使用的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送 Runnable 消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//一般更新 UI 时发送的消息，延时时间为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送延时消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送指定时间发送的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//把字节传入 Message 中一起发送</span></span><br><span class="line"><span class="comment">//Looper 中需要使用 Handler 来执行 dispatchMessage 方法</span></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-ActivityThread-创建默认的-Handler"><a href="#4-ActivityThread-创建默认的-Handler" class="headerlink" title="4. ActivityThread 创建默认的 Handler"></a>4. ActivityThread 创建默认的 Handler</h4><p>上面说过，ActivityThread 主线程默认是有一个 Handler 的，我们来看一下主线程是怎么创建默认的 Handler 的。</p><p>我们看一下 ActivityThread 类中的 main 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();<span class="comment">//准备一些相关环境，给我们的组件启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();<span class="comment">//初始化主线程 Looper</span></span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();<span class="comment">//开启消息轮询，不断取出消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Activity 可以直接用 runOnUiThread() 来使用默认的 Handler 发送消息，我们来看下它是怎么实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;<span class="comment">//非主线程，发送 Runnable 消息</span></span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//在主线程中直接执行 run()</span></span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-HandlerThread-异步消息处理机制"><a href="#5-HandlerThread-异步消息处理机制" class="headerlink" title="5. HandlerThread 异步消息处理机制"></a>5. HandlerThread 异步消息处理机制</h4><blockquote><ol><li>HandlerThread 继承了 Thread，是一种可以使用 Handler 的 Thread；</li><li>在 run 方法中通过 looper.prepare() 来开启消息循环，这样就可以在 HandlerThread 中创<br>建Handler了；</li><li>外界可以通过一个 Handler 的消息方式来通知 HandlerThread 来执行具体任务；确定不使<br>用之后，可以通过 quit 或 quitSafely 方法来终止线程执行。</li></ol></blockquote><p>先分析一下 HandlerThread 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程的优先级</span></span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="comment">//线程的id</span></span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一个与Handler关联的Looper对象</span></span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="comment">//设置优先级为默认线程</span></span><br><span class="line">        mPriority = android.os.Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可重写方法，Looper.loop之前在线程中需要处理的其他逻辑在这里实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//HandlerThread线程的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程的id</span></span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        <span class="comment">//创建Looper对象</span></span><br><span class="line">        <span class="comment">//这就是为什么我们要在调用线程的start()方法后才能得到Looper(Looper.myLooper不为Null)</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="comment">//同步代码块，当获得mLooper对象后，唤醒所有线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置线程优先级</span></span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        <span class="comment">//Looper.loop之前在线程中需要处理的其他逻辑</span></span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        <span class="comment">//建立了消息循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="comment">//一般执行不到这句，除非quit消息队列</span></span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="comment">//线程死了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步代码块，正好和上面run方法中同步块对应</span></span><br><span class="line">        <span class="comment">//只要线程活着并且mLooper为null，则一直等待</span></span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//退出消息循环</span></span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//退出消息循环</span></span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回线程id</span></span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerThread 使用代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HandlerThread mHandlerThread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mThreadHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mUiHandler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"HandlerWorkThread"</span>);</span><br><span class="line">        <span class="comment">//必须在实例化mThreadHandler之前调运start方法，原因上面源码已经分析了</span></span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        <span class="comment">//将当前mHandlerThread子线程的Looper传入mThreadHandler，使得</span></span><br><span class="line">        <span class="comment">//mThreadHandler的消息队列依赖于子线程（在子线程中执行）</span></span><br><span class="line">        mThreadHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                Log.i(<span class="keyword">null</span>, <span class="string">"在子线程中处理！id="</span>+Thread.currentThread().getId());</span><br><span class="line">                <span class="comment">//从子线程往主线程发送消息</span></span><br><span class="line">                mUiHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mUiHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                Log.i(<span class="keyword">null</span>, <span class="string">"在UI主线程中处理！id="</span>+Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//从主线程往子线程发送消息</span></span><br><span class="line">        mThreadHandler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此 Handler 消息机制的源码已经分析完了，相信你一定明白了 Handler 消息机制。<br><br>一句话，每个线程可以创建一个 Looper ，每个 Looper 轮询着一个 MessageQueue 不断取出消息，有消息则回调给 Handler，Handler 负责向 MessageQueue 中发送消息和处理回调的消息来完成线程之间的转换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Handler消息机制&quot;&gt;&lt;a href=&quot;#Android-Handler消息机制&quot; class=&quot;headerlink&quot; title=&quot;Android-Handler消息机制&quot;&gt;&lt;/a&gt;Android-Handler消息机制&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="Handler" scheme="https://cohleke.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Android Binder进程间通讯</title>
    <link href="https://cohleke.github.io/2017/12/30/Android%20Binder%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://cohleke.github.io/2017/12/30/Android Binder进程间通讯/</id>
    <published>2017-12-30T08:41:27.000Z</published>
    <updated>2018-03-11T08:51:41.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Binder进程间通讯"><a href="#Android-Binder进程间通讯" class="headerlink" title="Android-Binder进程间通讯"></a>Android-Binder进程间通讯</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在学习 Binder 机制，在网上查阅了大量的资料，也看了老罗的 Binder 系列的博客和 Innost 的深入理解 Binder 系列的博客，都是从底层开始讲的，全是 C 代码，虽然之前学过 C 和 C++，然而各种函数之间花式跳转，看的我都怀疑人生。 毫不夸张的讲每看一遍都是新的内容，跟没看过一样。 后来又看到了 Gityuan 的博客看到了一些图解仿佛发现了新大陆。 </p><p>下面就以图解的方式介绍下 Binder 机制，相信你看这篇文章，一定有所收获。</p><h2 id="什么是-Binder？"><a href="#什么是-Binder？" class="headerlink" title="什么是 Binder？"></a>什么是 Binder？</h2><p>Binder 是 Android 系统中进程间通讯（IPC）的一种方式，也是 Android 系统中最重要的特性之一。 Android 中的四大组件 Activity，Service，Broadcast，ContentProvider，不同的 App 等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。</p><p>理解 Binder 对于理解整个 Android 系统有着非常重要的作用，如果对 Binder 不了解，就很难对 Android 系统机制有更深入的理解。</p><h2 id="1-Binder-架构"><a href="#1-Binder-架构" class="headerlink" title="1. Binder 架构"></a>1. Binder 架构</h2><img src="/2017/12/30/Android%20Binder进程间通讯/01.jpg" title="Binder 架构"><ul><li>Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。</li><li>Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 </li><li>Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。</li></ul><h2 id="2-Binder-机制"><a href="#2-Binder-机制" class="headerlink" title="2. Binder 机制"></a>2. Binder 机制</h2><img src="/2017/12/30/Android%20Binder进程间通讯/08.jpg" title="Binder 机制"><ul><li><p>首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。</p></li><li><p>有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取WindowManager服务引用</span></span><br><span class="line">WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE);</span><br></pre></td></tr></table></figure><p>  获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。</p></li><li><p>有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。</p></li></ul><p>怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。</p><h2 id="3-Binder-驱动"><a href="#3-Binder-驱动" class="headerlink" title="3. Binder 驱动"></a>3. Binder 驱动</h2><p>我们先来了解下用户空间与内核空间是怎么交互的。</p><img src="/2017/12/30/Android%20Binder进程间通讯/02.jpg" title="用户空间与内核空间"><p>先了解一些概念</p><h3 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间/内核空间"></a>用户空间/内核空间</h3><p>详细解释可以参考 <a href="http://www.linfo.org/kernel_space.html" target="_blank" rel="noopener">Kernel Space Definition</a>； 简单理解如下：</p><p>Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p><p>Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。</p><h3 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h3><p>虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？</p><blockquote><p>Kernel space can be accessed by user processes only through the use of system calls.</p></blockquote><p>用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。</p><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p><h3 id="内核模块-驱动"><a href="#内核模块-驱动" class="headerlink" title="内核模块/驱动"></a>内核模块/驱动</h3><p>通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p><p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动;</p><blockquote><p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；</p></blockquote><p>驱动就是操作硬件的接口，为了支持 Binder 通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。</p><p>熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。</p><h2 id="4-Binder-进程与线程"><a href="#4-Binder-进程与线程" class="headerlink" title="4. Binder 进程与线程"></a>4. Binder 进程与线程</h2><img src="/2017/12/30/Android%20Binder进程间通讯/03.jpg" title="进程与线程"><p>对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。</p><p>Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。</p><h2 id="5-ServiceManager-启动"><a href="#5-ServiceManager-启动" class="headerlink" title="5. ServiceManager 启动"></a>5. ServiceManager 启动</h2><p>了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。</p><img src="/2017/12/30/Android%20Binder进程间通讯/04.jpg" title="Binder 驱动"><ul><li><p>ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。</p></li><li><p>ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。</p></li><li><p>ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。</p></li></ul><h2 id="6-ServiceManager-注册服务"><a href="#6-ServiceManager-注册服务" class="headerlink" title="6. ServiceManager 注册服务"></a>6. ServiceManager 注册服务</h2><img src="/2017/12/30/Android%20Binder进程间通讯/05.jpg" title="注册服务"><ul><li><p>注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。</p></li><li><p>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。</p></li><li><p>事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。</p></li></ul><h2 id="7-ServiceManager-获取服务"><a href="#7-ServiceManager-获取服务" class="headerlink" title="7. ServiceManager 获取服务"></a>7. ServiceManager 获取服务</h2><img src="/2017/12/30/Android%20Binder进程间通讯/06.jpg" title="获取服务"><ul><li><p>获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。</p></li><li><p>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。</p></li><li><p>Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。</p></li></ul><h2 id="8-进行一次完整通讯"><a href="#8-进行一次完整通讯" class="headerlink" title="8. 进行一次完整通讯"></a>8. 进行一次完整通讯</h2><img src="/2017/12/30/Android%20Binder进程间通讯/07.jpg" title="完整通讯"><ul><li><p>我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。</p></li><li><p>首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给  ServiceManager，同时客户端线程进入等待状态。</p></li><li><p>ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。 努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。</p><p>网上资料很多，个人觉得比较好的如下：</p><ol><li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Bander设计与实现</a></li><li>老罗的 <a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a> 系列</li><li>Innost的 <a href="http://blog.csdn.net/innost/article/details/47208049" target="_blank" rel="noopener">深入理解Binder</a> 系列</li><li>Gityuan的 <a href="http://gityuan.com/2015/10/31/binder-prepare" target="_blank" rel="noopener">Binder系列</a> (基于 Android 6.0)</li><li><a href="http://weishu.me/2016/01/12/binder-index-for-newer" target="_blank" rel="noopener">Binder学习指南</a></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gityuan.com/2015/10/31/binder-prepare" target="_blank" rel="noopener">Binder系列</a></li><li><a href="http://weishu.me/2016/01/12/binder-index-for-newer" target="_blank" rel="noopener">Binder学习指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Binder进程间通讯&quot;&gt;&lt;a href=&quot;#Android-Binder进程间通讯&quot; class=&quot;headerlink&quot; title=&quot;Android-Binder进程间通讯&quot;&gt;&lt;/a&gt;Android-Binder进程间通讯&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Android" scheme="https://cohleke.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cohleke.github.io/tags/Android/"/>
    
      <category term="Binder" scheme="https://cohleke.github.io/tags/Binder/"/>
    
  </entry>
  
</feed>
